{
  "1146": {
    "id": "1146",
    "label": "I want to be notified when all of them have completed",
    "options": [
      "9363"
    ]
  },
  "1214": {
    "id": "1214",
    "label": "using a specific subject implementation",
    "options": [
      "8fe7"
    ]
  },
  "1285": {
    "id": "1285",
    "label": "window"
  },
  "1474": {
    "id": "1474",
    "label": "concat"
  },
  "1757": {
    "id": "1757",
    "label": "I want to re-subscribe",
    "options": [
      "7458",
      "35f4"
    ]
  },
  "2271": {
    "id": "2271",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "a39b"
    ]
  },
  "2883": {
    "id": "2883",
    "label": "takeLast"
  },
  "3104": {
    "id": "3104",
    "label": "I want to prepend one value",
    "options": [
      "5676"
    ]
  },
  "3293": {
    "id": "3293",
    "label": "I want to switch to another Observable",
    "options": [
      "a5d7"
    ]
  },
  "3697": {
    "id": "3697",
    "label": "count"
  },
  "3782": {
    "id": "3782",
    "label": "bufferWhen"
  },
  "3904": {
    "id": "3904",
    "label": "using an AsyncSubject",
    "options": [
      "4abf"
    ]
  },
  "3954": {
    "id": "3954",
    "label": "mergeMapTo"
  },
  "4367": {
    "id": "4367",
    "label": "race"
  },
  "4400": {
    "id": "4400",
    "label": "EMPTY"
  },
  "4628": {
    "id": "4628",
    "label": "with an optional initial delay",
    "options": [
      "9580"
    ]
  },
  "5523": {
    "id": "5523",
    "label": "concatMap"
  },
  "5574": {
    "id": "5574",
    "label": "windowTime"
  },
  "5676": {
    "id": "5676",
    "label": "startWith"
  },
  "5843": {
    "id": "5843",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "4367"
    ]
  },
  "5888": {
    "id": "5888",
    "label": "I want to wrap its messages with metadata",
    "options": [
      "df92",
      "917d"
    ]
  },
  "5958": {
    "id": "5958",
    "label": "mergeMap"
  },
  "5969": {
    "id": "5969",
    "label": "defer"
  },
  "5977": {
    "id": "5977",
    "label": "share"
  },
  "6516": {
    "id": "6516",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "4f2e"
    ]
  },
  "6808": {
    "id": "6808",
    "label": "mapTo"
  },
  "6847": {
    "id": "6847",
    "label": "and only the first value",
    "options": [
      "5f73"
    ]
  },
  "7019": {
    "id": "7019",
    "label": "I want to start a new Observable",
    "options": [
      "b603"
    ]
  },
  "7044": {
    "id": "7044",
    "label": "elementAt"
  },
  "7326": {
    "id": "7326",
    "label": "when it completes, errors or unsubscribes, I want to execute a function",
    "options": [
      "c076"
    ]
  },
  "7454": {
    "id": "7454",
    "label": "over the values in an array",
    "options": [
      "dd0b"
    ]
  },
  "7458": {
    "id": "7458",
    "label": "immediately",
    "options": [
      "c850"
    ]
  },
  "7827": {
    "id": "7827",
    "label": "if they are at the end of the Observable",
    "options": [
      "89b4",
      "f413"
    ]
  },
  "7885": {
    "id": "7885",
    "label": "takeWhile"
  },
  "8791": {
    "id": "8791",
    "label": "to be a value calculated through a formula",
    "options": [
      "f21e"
    ]
  },
  "9153": {
    "id": "9153",
    "label": "and output the computed values as a nested Observable when the source emits a value",
    "options": [
      "30f3"
    ]
  },
  "9156": {
    "id": "9156",
    "label": "which is built on demand when subscribed",
    "options": [
      "5969"
    ]
  },
  "9175": {
    "id": "9175",
    "label": "throwError"
  },
  "9241": {
    "id": "9241",
    "label": "tap"
  },
  "9363": {
    "id": "9363",
    "label": "forkJoin"
  },
  "9503": {
    "id": "9503",
    "label": "I want to ignore values",
    "options": [
      "93a1",
      "61d3",
      "9580",
      "54e0",
      "bf78",
      "3f89"
    ]
  },
  "9580": {
    "id": "9580",
    "label": "timer"
  },
  "9924": {
    "id": "9924",
    "label": "based on a given amount",
    "options": [
      "9987"
    ]
  },
  "9987": {
    "id": "9987",
    "label": "take"
  },
  "fdf9": {
    "id": "fdf9",
    "label": "to be a constant value",
    "options": [
      "6808"
    ]
  },
  "f21e": {
    "id": "f21e",
    "label": "map"
  },
  "5f4a": {
    "id": "5f4a",
    "label": "I want to change each emitted value",
    "options": [
      "fdf9",
      "8791"
    ]
  },
  "6dce": {
    "id": "6dce",
    "label": "pluck"
  },
  "10d2": {
    "id": "10d2",
    "label": "I want to pick a property off each emitted value",
    "options": [
      "6dce"
    ]
  },
  "0461": {
    "id": "0461",
    "label": "I want to spy the values being emitted without affecting them",
    "options": [
      "9241"
    ]
  },
  "c9fa": {
    "id": "c9fa",
    "label": "filter"
  },
  "0f5c": {
    "id": "0f5c",
    "label": "based on custom logic",
    "options": [
      "c9fa"
    ]
  },
  "5f73": {
    "id": "5f73",
    "label": "first"
  },
  "3cb1": {
    "id": "3cb1",
    "label": "based on custom logic",
    "options": [
      "7885"
    ]
  },
  "06e4": {
    "id": "06e4",
    "label": "if they are at the start of the Observable",
    "options": [
      "6847",
      "9924",
      "3cb1"
    ]
  },
  "49b0": {
    "id": "49b0",
    "label": "if they are exactly the n-th emission",
    "options": [
      "7044"
    ]
  },
  "fd12": {
    "id": "fd12",
    "label": "last"
  },
  "89b4": {
    "id": "89b4",
    "label": "and only the last value",
    "options": [
      "fd12"
    ]
  },
  "f413": {
    "id": "f413",
    "label": "based on a given amount",
    "options": [
      "2883"
    ]
  },
  "e021": {
    "id": "e021",
    "label": "takeUntil"
  },
  "f775": {
    "id": "f775",
    "label": "until another Observable emits a value",
    "options": [
      "e021"
    ]
  },
  "0931": {
    "id": "0931",
    "label": "I want to allow some values to pass",
    "options": [
      "0f5c",
      "06e4",
      "49b0",
      "7827",
      "f775"
    ]
  },
  "08d1": {
    "id": "08d1",
    "label": "ignoreElements"
  },
  "93a1": {
    "id": "93a1",
    "label": "altogether",
    "options": [
      "08d1"
    ]
  },
  "1b91": {
    "id": "1b91",
    "label": "skip"
  },
  "1e2b": {
    "id": "1e2b",
    "label": "based on a given amount",
    "options": [
      "1b91"
    ]
  },
  "996d": {
    "id": "996d",
    "label": "skipWhile"
  },
  "e0f7": {
    "id": "e0f7",
    "label": "based on custom logic",
    "options": [
      "996d"
    ]
  },
  "61d3": {
    "id": "61d3",
    "label": "from the start of the Observable",
    "options": [
      "1e2b",
      "e0f7"
    ]
  },
  "c2e1": {
    "id": "c2e1",
    "label": "skipLast"
  },
  "1b18": {
    "id": "1b18",
    "label": "skipUntil"
  },
  "54e0": {
    "id": "54e0",
    "label": "until another Observable emits a value",
    "options": [
      "1b18"
    ]
  },
  "76b8": {
    "id": "76b8",
    "label": "distinctUntilChanged"
  },
  "3bee": {
    "id": "3bee",
    "label": "emitted just before the current value",
    "options": [
      "76b8"
    ]
  },
  "c90a": {
    "id": "c90a",
    "label": "distinct"
  },
  "1ebe": {
    "id": "1ebe",
    "label": "emitted some time in the past",
    "options": [
      "c90a"
    ]
  },
  "51b3": {
    "id": "51b3",
    "label": "according to value equality",
    "options": [
      "3bee",
      "1ebe"
    ]
  },
  "d5c4": {
    "id": "d5c4",
    "label": "distinctUntilKeyChanged"
  },
  "625b": {
    "id": "625b",
    "label": "emitted just before the current value",
    "options": [
      "d5c4"
    ]
  },
  "d1af": {
    "id": "d1af",
    "label": "according to a key or object property",
    "options": [
      "625b"
    ]
  },
  "bf78": {
    "id": "bf78",
    "label": "that match some previous value",
    "options": [
      "51b3",
      "d1af"
    ]
  },
  "bcb8": {
    "id": "bcb8",
    "label": "throttle"
  },
  "bbf9": {
    "id": "bbf9",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "bcb8"
    ]
  },
  "c32e": {
    "id": "c32e",
    "label": "throttleTime"
  },
  "33cc": {
    "id": "33cc",
    "label": "where time windows are determined by a time duration",
    "options": [
      "c32e"
    ]
  },
  "e605": {
    "id": "e605",
    "label": "by emitting the first value in each time window",
    "options": [
      "bbf9",
      "33cc"
    ]
  },
  "3f3d": {
    "id": "3f3d",
    "label": "audit"
  },
  "6e7d": {
    "id": "6e7d",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "3f3d"
    ]
  },
  "ae23": {
    "id": "ae23",
    "label": "auditTime"
  },
  "cade": {
    "id": "cade",
    "label": "where time windows are determined by a time duration",
    "options": [
      "ae23"
    ]
  },
  "cc2f": {
    "id": "cc2f",
    "label": "by emitting the last value in each time window",
    "options": [
      "6e7d",
      "cade"
    ]
  },
  "0884": {
    "id": "0884",
    "label": "debounce"
  },
  "efbd": {
    "id": "efbd",
    "label": "where the silence duration threshold is determined by another Observable",
    "options": [
      "0884"
    ]
  },
  "7eab": {
    "id": "7eab",
    "label": "debounceTime"
  },
  "53ea": {
    "id": "53ea",
    "label": "where the silence duration threshold is determined by a time duration",
    "options": [
      "7eab"
    ]
  },
  "25f4": {
    "id": "25f4",
    "label": "by emitting the last value as soon as enough silence has occured",
    "options": [
      "efbd",
      "53ea"
    ]
  },
  "3f89": {
    "id": "3f89",
    "label": "that occur too frequently",
    "options": [
      "e605",
      "cc2f",
      "25f4"
    ]
  },
  "f93e": {
    "id": "f93e",
    "label": "reduce"
  },
  "5dd0": {
    "id": "5dd0",
    "label": "and only output the final computed value",
    "options": [
      "f93e"
    ]
  },
  "a526": {
    "id": "a526",
    "label": "scan"
  },
  "3b57": {
    "id": "3b57",
    "label": "and output the computed values when the source emits a value",
    "options": [
      "a526"
    ]
  },
  "30f3": {
    "id": "30f3",
    "label": "mergeScan"
  },
  "3e08": {
    "id": "3e08",
    "label": "I want to compute a formula using all values emitted",
    "options": [
      "5dd0",
      "3b57",
      "9153"
    ]
  },
  "02a1": {
    "id": "02a1",
    "label": "materialize"
  },
  "df92": {
    "id": "df92",
    "label": "that describes each notification (next, error, or complete)",
    "options": [
      "02a1"
    ]
  },
  "d763": {
    "id": "d763",
    "label": "timeInterval"
  },
  "917d": {
    "id": "917d",
    "label": "that includes the time past since the last emitted value",
    "options": [
      "d763"
    ]
  },
  "c046": {
    "id": "c046",
    "label": "timeout"
  },
  "adbf": {
    "id": "adbf",
    "label": "I want to throw an error",
    "options": [
      "c046"
    ]
  },
  "a5d7": {
    "id": "a5d7",
    "label": "timeoutWith"
  },
  "68e7": {
    "id": "68e7",
    "label": "after a period of inactivity",
    "options": [
      "adbf",
      "3293"
    ]
  },
  "cfa3": {
    "id": "cfa3",
    "label": "single"
  },
  "b6e7": {
    "id": "b6e7",
    "label": "I want to ensure there is only one value",
    "options": [
      "cfa3"
    ]
  },
  "c001": {
    "id": "c001",
    "label": "I want to know how many values it emits",
    "options": [
      "3697"
    ]
  },
  "6b85": {
    "id": "6b85",
    "label": "delay"
  },
  "77ed": {
    "id": "77ed",
    "label": "based on a given amount of time",
    "options": [
      "6b85"
    ]
  },
  "0032": {
    "id": "0032",
    "label": "delayWhen"
  },
  "df5c": {
    "id": "df5c",
    "label": "based on the emissions of another Observable",
    "options": [
      "0032"
    ]
  },
  "247c": {
    "id": "247c",
    "label": "and emit the values from each nested Observable in order",
    "options": [
      "2271",
      "7af9"
    ]
  },
  "30ff": {
    "id": "30ff",
    "label": "toArray"
  },
  "278c": {
    "id": "278c",
    "label": "and convert to an array",
    "options": [
      "30ff"
    ]
  },
  "dcf2": {
    "id": "dcf2",
    "label": "Observable",
    "method": "toPromise"
  },
  "6e37": {
    "id": "6e37",
    "label": "and convert to a Promise",
    "options": [
      "dcf2"
    ]
  },
  "46c8": {
    "id": "46c8",
    "label": "until the Observable completes",
    "options": [
      "278c",
      "6e37"
    ]
  },
  "dcd6": {
    "id": "dcd6",
    "label": "pairwise"
  },
  "3bfa": {
    "id": "3bfa",
    "label": "consecutively in pairs, as arrays",
    "options": [
      "dcd6"
    ]
  },
  "d5c6": {
    "id": "d5c6",
    "label": "partition"
  },
  "b39e": {
    "id": "b39e",
    "label": "based on a criterion, and output two Observables: those that match the criterion and those that do not",
    "options": [
      "d5c6"
    ]
  },
  "a74e": {
    "id": "a74e",
    "label": "bufferCount"
  },
  "6ad7": {
    "id": "6ad7",
    "label": "and emit the group as an array",
    "options": [
      "a74e"
    ]
  },
  "3b27": {
    "id": "3b27",
    "label": "windowCount"
  },
  "66d1": {
    "id": "66d1",
    "label": "and emit the group as a nested Observable",
    "options": [
      "3b27"
    ]
  },
  "c3a0": {
    "id": "c3a0",
    "label": "in batches of a particular size",
    "options": [
      "6ad7",
      "66d1"
    ]
  },
  "da93": {
    "id": "da93",
    "label": "bufferTime"
  },
  "608e": {
    "id": "608e",
    "label": "and emit the group as an array",
    "options": [
      "da93"
    ]
  },
  "5f37": {
    "id": "5f37",
    "label": "and cancel the previous nested Observable when a new value arrives",
    "options": [
      "040c",
      "4fe5"
    ]
  },
  "e6c4": {
    "id": "e6c4",
    "label": "based on time",
    "options": [
      "608e",
      "5f37"
    ]
  },
  "51b4": {
    "id": "51b4",
    "label": "buffer"
  },
  "a786": {
    "id": "a786",
    "label": "and emit the group as an array",
    "options": [
      "51b4"
    ]
  },
  "5f42": {
    "id": "5f42",
    "label": "and emit the group as a nested Observable",
    "options": [
      "1285"
    ]
  },
  "02fe": {
    "id": "02fe",
    "label": "until another Observable emits",
    "options": [
      "a786",
      "5f42"
    ]
  },
  "ef50": {
    "id": "ef50",
    "label": "and emit the group as an array",
    "options": [
      "3782"
    ]
  },
  "f538": {
    "id": "f538",
    "label": "windowWhen"
  },
  "2c0e": {
    "id": "2c0e",
    "label": "and emit the group as a nested Observable",
    "options": [
      "f538"
    ]
  },
  "240c": {
    "id": "240c",
    "label": "based on the emissions of an Observable created on-demand",
    "options": [
      "ef50",
      "2c0e"
    ]
  },
  "1d56": {
    "id": "1d56",
    "label": "bufferToggle"
  },
  "f729": {
    "id": "f729",
    "label": "and emit the group as an array",
    "options": [
      "1d56"
    ]
  },
  "aa7b": {
    "id": "aa7b",
    "label": "windowToggle"
  },
  "2d26": {
    "id": "2d26",
    "label": "and emit the group as a nested Observable",
    "options": [
      "aa7b"
    ]
  },
  "c89a": {
    "id": "c89a",
    "label": "based on another Observable for opening a group, and an Observable for closing a group",
    "options": [
      "f729",
      "2d26"
    ]
  },
  "c80c": {
    "id": "c80c",
    "label": "groupBy"
  },
  "f2e9": {
    "id": "f2e9",
    "label": "based on a key calculated from the emitted values",
    "options": [
      "c80c"
    ]
  },
  "b5fe": {
    "id": "b5fe",
    "label": "I want to group the values",
    "options": [
      "46c8",
      "3bfa",
      "b39e",
      "c3a0",
      "e6c4",
      "02fe",
      "240c",
      "c89a",
      "f2e9"
    ]
  },
  "c16b": {
    "id": "c16b",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "3954"
    ]
  },
  "b433": {
    "id": "b433",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "5958"
    ]
  },
  "aa54": {
    "id": "aa54",
    "label": "and emit the values from all nested Observables in parallel",
    "options": [
      "c16b",
      "b433"
    ]
  },
  "a39b": {
    "id": "a39b",
    "label": "concatMapTo"
  },
  "7af9": {
    "id": "7af9",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "5523"
    ]
  },
  "801b": {
    "id": "801b",
    "label": "switchMapTo"
  },
  "040c": {
    "id": "040c",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "801b"
    ]
  },
  "ae4e": {
    "id": "ae4e",
    "label": "switchMap"
  },
  "4fe5": {
    "id": "4fe5",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "ae4e"
    ]
  },
  "22f0": {
    "id": "22f0",
    "label": "exhaustMap"
  },
  "7b3a": {
    "id": "7b3a",
    "label": "and ignore incoming values while the current nested Observable has not yet completed",
    "options": [
      "22f0"
    ]
  },
  "922c": {
    "id": "922c",
    "label": "expand"
  },
  "e4d8": {
    "id": "e4d8",
    "label": "and recursively start a new Observable for each new value",
    "options": [
      "922c"
    ]
  },
  "9bef": {
    "id": "9bef",
    "label": "I want to start a new Observable for each value",
    "options": [
      "aa54",
      "247c",
      "5f37",
      "7b3a",
      "e4d8"
    ]
  },
  "a3d5": {
    "id": "a3d5",
    "label": "pipe"
  },
  "039c": {
    "id": "039c",
    "label": "I want to perform custom operations",
    "options": [
      "a3d5"
    ]
  },
  "1c55": {
    "id": "1c55",
    "label": "and start it as soon as the first subscriber arrives",
    "options": [
      "5977"
    ]
  },
  "1aeb": {
    "id": "1aeb",
    "label": "publish"
  },
  "87ac": {
    "id": "87ac",
    "label": "and start it manually or imperatively",
    "options": [
      "1aeb"
    ]
  },
  "7f6e": {
    "id": "7f6e",
    "label": "using a conventional Subject",
    "options": [
      "1c55",
      "87ac"
    ]
  },
  "826d": {
    "id": "826d",
    "label": "publishBehavior"
  },
  "dbf1": {
    "id": "dbf1",
    "label": "using a BehaviorSubject",
    "options": [
      "826d"
    ]
  },
  "c4fd": {
    "id": "c4fd",
    "label": "publishReplay"
  },
  "3f90": {
    "id": "3f90",
    "label": "using a ReplaySubject",
    "options": [
      "c4fd"
    ]
  },
  "4abf": {
    "id": "4abf",
    "label": "publishLast"
  },
  "8fe7": {
    "id": "8fe7",
    "label": "multicast"
  },
  "fdac": {
    "id": "fdac",
    "label": "I want to share a subscription between multiple subscribers",
    "options": [
      "7f6e",
      "dbf1",
      "3f90",
      "3904",
      "1214"
    ]
  },
  "47fc": {
    "id": "47fc",
    "label": "catchError"
  },
  "ea45": {
    "id": "ea45",
    "label": "I want to start a new Observable",
    "options": [
      "47fc"
    ]
  },
  "c850": {
    "id": "c850",
    "label": "retry"
  },
  "734d": {
    "id": "734d",
    "label": "retryWhen"
  },
  "35f4": {
    "id": "35f4",
    "label": "when another Observable emits",
    "options": [
      "734d"
    ]
  },
  "7c4f": {
    "id": "7c4f",
    "label": "when an error occurs",
    "options": [
      "ea45",
      "1757"
    ]
  },
  "1c9a": {
    "id": "1c9a",
    "label": "repeat"
  },
  "bd90": {
    "id": "bd90",
    "label": "immediately",
    "options": [
      "1c9a"
    ]
  },
  "f071": {
    "id": "f071",
    "label": "repeatWhen"
  },
  "5ea4": {
    "id": "5ea4",
    "label": "when another Observable emits",
    "options": [
      "f071"
    ]
  },
  "63be": {
    "id": "63be",
    "label": "I want to re-subscribe",
    "options": [
      "bd90",
      "5ea4"
    ]
  },
  "b603": {
    "id": "b603",
    "label": "concat"
  },
  "b0f3": {
    "id": "b0f3",
    "label": "when it completes",
    "options": [
      "63be",
      "7019"
    ]
  },
  "c076": {
    "id": "c076",
    "label": "finalize"
  },
  "2def": {
    "id": "2def",
    "label": "subscribeOn"
  },
  "77f9": {
    "id": "77f9",
    "label": "that routes calls to subscribe",
    "options": [
      "2def"
    ]
  },
  "e2ac": {
    "id": "e2ac",
    "label": "observeOn"
  },
  "fa19": {
    "id": "fa19",
    "label": "that routes values to observers",
    "options": [
      "e2ac"
    ]
  },
  "a3fa": {
    "id": "a3fa",
    "label": "I want to change the scheduler",
    "options": [
      "77f9",
      "fa19"
    ]
  },
  "950e": {
    "id": "950e",
    "label": "merge"
  },
  "7a82": {
    "id": "7a82",
    "label": "I want to output the values from either of them",
    "options": [
      "950e"
    ]
  },
  "4f2e": {
    "id": "4f2e",
    "label": "combineLatest"
  },
  "dc0c": {
    "id": "dc0c",
    "label": "withLatestFrom"
  },
  "c2f6": {
    "id": "c2f6",
    "label": "using the latest value of each source only when the primary Observable emits",
    "options": [
      "dc0c"
    ]
  },
  "89a4": {
    "id": "89a4",
    "label": "zip"
  },
  "cd86": {
    "id": "cd86",
    "label": "using each source value only once",
    "options": [
      "89a4"
    ]
  },
  "0050": {
    "id": "0050",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "6516",
      "c2f6",
      "cd86"
    ]
  },
  "df8d": {
    "id": "df8d",
    "label": "I want to combine this Observable with others, and",
    "options": [
      "5843",
      "7a82",
      "0050"
    ]
  },
  "7c8e": {
    "id": "7c8e",
    "label": "I have one existing Observable, and",
    "options": [
      "5f4a",
      "10d2",
      "0461",
      "0931",
      "9503",
      "3e08",
      "5888",
      "68e7",
      "b6e7",
      "c001",
      "3104",
      "247c",
      "b5fe",
      "9bef",
      "039c",
      "fdac",
      "7c4f",
      "b0f3",
      "7326",
      "a3fa",
      "df8d"
    ]
  },
  "a7b7": {
    "id": "a7b7",
    "label": "race"
  },
  "d37c": {
    "id": "d37c",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "a7b7"
    ]
  },
  "de31": {
    "id": "de31",
    "label": "merge"
  },
  "5e61": {
    "id": "5e61",
    "label": "I want to output the values from either of them",
    "options": [
      "de31"
    ]
  },
  "87ae": {
    "id": "87ae",
    "label": "combineLatest"
  },
  "05ee": {
    "id": "05ee",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "87ae"
    ]
  },
  "ec8c": {
    "id": "ec8c",
    "label": "zip"
  },
  "c43c": {
    "id": "c43c",
    "label": "using each source value only once",
    "options": [
      "ec8c"
    ]
  },
  "53dc": {
    "id": "53dc",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "05ee",
      "c43c"
    ]
  },
  "37df": {
    "id": "37df",
    "label": "I want to subscribe to each in order",
    "options": [
      "1474"
    ]
  },
  "1b11": {
    "id": "1b11",
    "label": "I have some Observables to combine together as one Observable, and",
    "options": [
      "d37c",
      "1146",
      "5e61",
      "53dc",
      "37df"
    ]
  },
  "0e8a": {
    "id": "0e8a",
    "label": "Observable",
    "method": "create"
  },
  "eebd": {
    "id": "eebd",
    "label": "using custom logic",
    "options": [
      "0e8a"
    ]
  },
  "73ec": {
    "id": "73ec",
    "label": "generate"
  },
  "7db7": {
    "id": "7db7",
    "label": "using a state machine similar to a for loop",
    "options": [
      "73ec"
    ]
  },
  "269b": {
    "id": "269b",
    "label": "that throws an error",
    "options": [
      "9175"
    ]
  },
  "a69f": {
    "id": "a69f",
    "label": "that just completes, without emitting values",
    "options": [
      "4400"
    ]
  },
  "2b71": {
    "id": "2b71",
    "label": "NEVER"
  },
  "ed77": {
    "id": "ed77",
    "label": "that never emits anything",
    "options": [
      "2b71"
    ]
  },
  "0434": {
    "id": "0434",
    "label": "fromEvent"
  },
  "9f97": {
    "id": "9f97",
    "label": "coming from the DOM or Node.js or similar",
    "options": [
      "0434"
    ]
  },
  "53da": {
    "id": "53da",
    "label": "fromEventPattern"
  },
  "81ca": {
    "id": "81ca",
    "label": "that uses an API to add and remove event handlers",
    "options": [
      "53da"
    ]
  },
  "b181": {
    "id": "b181",
    "label": "from an existing source of events",
    "options": [
      "9f97",
      "81ca"
    ]
  },
  "a028": {
    "id": "a028",
    "label": "from"
  },
  "bb99": {
    "id": "bb99",
    "label": "from a Promise or an event source",
    "options": [
      "a028"
    ]
  },
  "dd0b": {
    "id": "dd0b",
    "label": "from"
  },
  "586e": {
    "id": "586e",
    "label": "range"
  },
  "30f5": {
    "id": "30f5",
    "label": "over values in a numeric range",
    "options": [
      "586e"
    ]
  },
  "b359": {
    "id": "b359",
    "label": "of"
  },
  "b5d5": {
    "id": "b5d5",
    "label": "over prefined values given as arguments",
    "options": [
      "b359"
    ]
  },
  "7e7c": {
    "id": "7e7c",
    "label": "that iterates",
    "options": [
      "7454",
      "30f5",
      "b5d5"
    ]
  },
  "093d": {
    "id": "093d",
    "label": "interval"
  },
  "4e6d": {
    "id": "4e6d",
    "label": "regularly",
    "options": [
      "093d"
    ]
  },
  "c5dd": {
    "id": "c5dd",
    "label": "that emits values on a timer",
    "options": [
      "4e6d",
      "4628"
    ]
  },
  "db0d": {
    "id": "db0d",
    "label": "I want to create a new Observable",
    "options": [
      "eebd",
      "7db7",
      "269b",
      "a69f",
      "ed77",
      "b181",
      "bb99",
      "7e7c",
      "c5dd",
      "9156"
    ]
  },
  "b7f8": {
    "id": "b7f8",
    "label": "bindCallback"
  },
  "600d": {
    "id": "600d",
    "label": "supporting a conventional callback API",
    "options": [
      "b7f8"
    ]
  },
  "e279": {
    "id": "e279",
    "label": "bindNodeCallback"
  },
  "6c56": {
    "id": "6c56",
    "label": "supporting Node.js callback style API",
    "options": [
      "e279"
    ]
  },
  "30b9": {
    "id": "30b9",
    "label": "I want to convert a callback to an Observable",
    "options": [
      "600d",
      "6c56"
    ]
  },
  "b2dc": {
    "id": "b2dc",
    "label": "I have no Observables yet, and",
    "options": [
      "db0d",
      "30b9"
    ]
  },
  "initial": {
    "id": "initial",
    "options": [
      "7c8e",
      "1b11",
      "b2dc"
    ]
  }
}