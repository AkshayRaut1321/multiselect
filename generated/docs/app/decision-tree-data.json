{
  "1012": {
    "id": "1012",
    "label": "I want to subscribe to each in order",
    "options": [
      "8542"
    ]
  },
  "2762": {
    "id": "2762",
    "label": "and only output the final computed value",
    "options": [
      "fd3d"
    ]
  },
  "3902": {
    "id": "3902",
    "label": "fromEventPattern"
  },
  "4249": {
    "id": "4249",
    "label": "using a state machine similar to a for loop",
    "options": [
      "2ab2"
    ]
  },
  "4280": {
    "id": "4280",
    "label": "race"
  },
  "4796": {
    "id": "4796",
    "label": "partition"
  },
  "4885": {
    "id": "4885",
    "label": "I want to create a new Observable",
    "options": [
      "bfb4",
      "4249",
      "586a",
      "c58a",
      "9e27",
      "a0fe",
      "d28f",
      "3c7f",
      "5249",
      "aefc"
    ]
  },
  "4998": {
    "id": "4998",
    "label": "mergeMapTo"
  },
  "5042": {
    "id": "5042",
    "label": "to be a value calculated through a formula",
    "options": [
      "6020"
    ]
  },
  "5119": {
    "id": "5119",
    "label": "and emit the group as an array",
    "options": [
      "a758"
    ]
  },
  "5197": {
    "id": "5197",
    "label": "using a BehaviorSubject",
    "options": [
      "d794"
    ]
  },
  "5249": {
    "id": "5249",
    "label": "that emits values on a timer",
    "options": [
      "7d72",
      "06e1"
    ]
  },
  "5507": {
    "id": "5507",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "d59e"
    ]
  },
  "5731": {
    "id": "5731",
    "label": "NEVER"
  },
  "6020": {
    "id": "6020",
    "label": "map"
  },
  "6150": {
    "id": "6150",
    "label": "from"
  },
  "6807": {
    "id": "6807",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "b3d2"
    ]
  },
  "6830": {
    "id": "6830",
    "label": "based on custom logic",
    "options": [
      "bd9b"
    ]
  },
  "6855": {
    "id": "6855",
    "label": "if they are at the start of the Observable",
    "options": [
      "d3fa",
      "f628",
      "edf1"
    ]
  },
  "6901": {
    "id": "6901",
    "label": "interval"
  },
  "7393": {
    "id": "7393",
    "label": "last"
  },
  "7437": {
    "id": "7437",
    "label": "emitted just before the current value",
    "options": [
      "65f7"
    ]
  },
  "7475": {
    "id": "7475",
    "label": "bindNodeCallback"
  },
  "7491": {
    "id": "7491",
    "label": "from"
  },
  "7549": {
    "id": "7549",
    "label": "timer"
  },
  "7603": {
    "id": "7603",
    "label": "where the silence duration threshold is determined by another Observable",
    "options": [
      "5aa5"
    ]
  },
  "7676": {
    "id": "7676",
    "label": "and emit the group as an array",
    "options": [
      "f2ac"
    ]
  },
  "8108": {
    "id": "8108",
    "label": "until another Observable emits a value",
    "options": [
      "bbfe"
    ]
  },
  "8279": {
    "id": "8279",
    "label": "auditTime"
  },
  "8542": {
    "id": "8542",
    "label": "concat"
  },
  "8694": {
    "id": "8694",
    "label": "using the latest value of each source only when the primary Observable emits",
    "options": [
      "2b9d"
    ]
  },
  "8744": {
    "id": "8744",
    "label": "when an error occurs",
    "options": [
      "e3b6",
      "58dc"
    ]
  },
  "8866": {
    "id": "8866",
    "label": "mergeScan"
  },
  "9538": {
    "id": "9538",
    "label": "scan"
  },
  "9592": {
    "id": "9592",
    "label": "expand"
  },
  "bdaf": {
    "id": "bdaf",
    "label": "mapTo"
  },
  "63ca": {
    "id": "63ca",
    "label": "to be a constant value",
    "options": [
      "bdaf"
    ]
  },
  "75cf": {
    "id": "75cf",
    "label": "I want to change each emitted value",
    "options": [
      "63ca",
      "5042"
    ]
  },
  "c2bc": {
    "id": "c2bc",
    "label": "pluck"
  },
  "b4a7": {
    "id": "b4a7",
    "label": "I want to pick a property off each emitted value",
    "options": [
      "c2bc"
    ]
  },
  "8ba4": {
    "id": "8ba4",
    "label": "tap"
  },
  "c869": {
    "id": "c869",
    "label": "I want to spy the values being emitted without affecting them",
    "options": [
      "8ba4"
    ]
  },
  "cba2": {
    "id": "cba2",
    "label": "filter"
  },
  "876b": {
    "id": "876b",
    "label": "based on custom logic",
    "options": [
      "cba2"
    ]
  },
  "dbe3": {
    "id": "dbe3",
    "label": "first"
  },
  "d3fa": {
    "id": "d3fa",
    "label": "and only the first value",
    "options": [
      "dbe3"
    ]
  },
  "e4f7": {
    "id": "e4f7",
    "label": "take"
  },
  "f628": {
    "id": "f628",
    "label": "based on a given amount",
    "options": [
      "e4f7"
    ]
  },
  "d745": {
    "id": "d745",
    "label": "takeWhile"
  },
  "edf1": {
    "id": "edf1",
    "label": "based on custom logic",
    "options": [
      "d745"
    ]
  },
  "0e81": {
    "id": "0e81",
    "label": "elementAt"
  },
  "0fa5": {
    "id": "0fa5",
    "label": "if they are exactly the n-th emission",
    "options": [
      "0e81"
    ]
  },
  "c648": {
    "id": "c648",
    "label": "and only the last value",
    "options": [
      "7393"
    ]
  },
  "6b11": {
    "id": "6b11",
    "label": "takeLast"
  },
  "d605": {
    "id": "d605",
    "label": "based on a given amount",
    "options": [
      "6b11"
    ]
  },
  "8fb2": {
    "id": "8fb2",
    "label": "if they are at the end of the Observable",
    "options": [
      "c648",
      "d605"
    ]
  },
  "f4ce": {
    "id": "f4ce",
    "label": "takeUntil"
  },
  "3a0e": {
    "id": "3a0e",
    "label": "until another Observable emits a value",
    "options": [
      "f4ce"
    ]
  },
  "0b10": {
    "id": "0b10",
    "label": "I want to allow some values to pass",
    "options": [
      "876b",
      "6855",
      "0fa5",
      "8fb2",
      "3a0e"
    ]
  },
  "48b6": {
    "id": "48b6",
    "label": "ignoreElements"
  },
  "e367": {
    "id": "e367",
    "label": "altogether",
    "options": [
      "48b6"
    ]
  },
  "3b72": {
    "id": "3b72",
    "label": "skip"
  },
  "0766": {
    "id": "0766",
    "label": "based on a given amount",
    "options": [
      "3b72"
    ]
  },
  "bd9b": {
    "id": "bd9b",
    "label": "skipWhile"
  },
  "b8fb": {
    "id": "b8fb",
    "label": "from the start of the Observable",
    "options": [
      "0766",
      "6830"
    ]
  },
  "c334": {
    "id": "c334",
    "label": "skipLast"
  },
  "b39a": {
    "id": "b39a",
    "label": "from the end of the Observable",
    "options": [
      "c334"
    ]
  },
  "bbfe": {
    "id": "bbfe",
    "label": "skipUntil"
  },
  "65f7": {
    "id": "65f7",
    "label": "distinctUntilChanged"
  },
  "d6d4": {
    "id": "d6d4",
    "label": "distinct"
  },
  "a2dc": {
    "id": "a2dc",
    "label": "emitted some time in the past",
    "options": [
      "d6d4"
    ]
  },
  "18aa": {
    "id": "18aa",
    "label": "according to value equality",
    "options": [
      "7437",
      "a2dc"
    ]
  },
  "afe6": {
    "id": "afe6",
    "label": "distinctUntilKeyChanged"
  },
  "b037": {
    "id": "b037",
    "label": "emitted just before the current value",
    "options": [
      "afe6"
    ]
  },
  "b76b": {
    "id": "b76b",
    "label": "according to a key or object property",
    "options": [
      "b037"
    ]
  },
  "406f": {
    "id": "406f",
    "label": "that match some previous value",
    "options": [
      "18aa",
      "b76b"
    ]
  },
  "fb39": {
    "id": "fb39",
    "label": "throttle"
  },
  "b63c": {
    "id": "b63c",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "fb39"
    ]
  },
  "93fe": {
    "id": "93fe",
    "label": "throttleTime"
  },
  "9a0b": {
    "id": "9a0b",
    "label": "where time windows are determined by a time duration",
    "options": [
      "93fe"
    ]
  },
  "bb42": {
    "id": "bb42",
    "label": "by emitting the first value in each time window",
    "options": [
      "b63c",
      "9a0b"
    ]
  },
  "f06b": {
    "id": "f06b",
    "label": "audit"
  },
  "da63": {
    "id": "da63",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "f06b"
    ]
  },
  "f1ca": {
    "id": "f1ca",
    "label": "where time windows are determined by a time duration",
    "options": [
      "8279"
    ]
  },
  "0c83": {
    "id": "0c83",
    "label": "by emitting the last value in each time window",
    "options": [
      "da63",
      "f1ca"
    ]
  },
  "5aa5": {
    "id": "5aa5",
    "label": "debounce"
  },
  "611d": {
    "id": "611d",
    "label": "debounceTime"
  },
  "7b50": {
    "id": "7b50",
    "label": "where the silence duration threshold is determined by a time duration",
    "options": [
      "611d"
    ]
  },
  "de5b": {
    "id": "de5b",
    "label": "by emitting the last value as soon as enough silence has occured",
    "options": [
      "7603",
      "7b50"
    ]
  },
  "7ebd": {
    "id": "7ebd",
    "label": "that occur too frequently",
    "options": [
      "bb42",
      "0c83",
      "de5b"
    ]
  },
  "55e2": {
    "id": "55e2",
    "label": "I want to ignore values",
    "options": [
      "e367",
      "b8fb",
      "b39a",
      "8108",
      "406f",
      "7ebd"
    ]
  },
  "fd3d": {
    "id": "fd3d",
    "label": "reduce"
  },
  "30ab": {
    "id": "30ab",
    "label": "and output the computed values when the source emits a value",
    "options": [
      "9538"
    ]
  },
  "ea7d": {
    "id": "ea7d",
    "label": "and output the computed values as a nested Observable when the source emits a value",
    "options": [
      "8866"
    ]
  },
  "21e4": {
    "id": "21e4",
    "label": "I want to compute a formula using all values emitted",
    "options": [
      "2762",
      "30ab",
      "ea7d"
    ]
  },
  "d507": {
    "id": "d507",
    "label": "materialize"
  },
  "4d46": {
    "id": "4d46",
    "label": "that describes each notification (next, error, or complete)",
    "options": [
      "d507"
    ]
  },
  "6b4e": {
    "id": "6b4e",
    "label": "timeInterval"
  },
  "dd2d": {
    "id": "dd2d",
    "label": "that includes the time past since the last emitted value",
    "options": [
      "6b4e"
    ]
  },
  "dc2a": {
    "id": "dc2a",
    "label": "I want to wrap its messages with metadata",
    "options": [
      "4d46",
      "dd2d"
    ]
  },
  "9e73": {
    "id": "9e73",
    "label": "timeout"
  },
  "d2ea": {
    "id": "d2ea",
    "label": "I want to throw an error",
    "options": [
      "9e73"
    ]
  },
  "b988": {
    "id": "b988",
    "label": "timeoutWith"
  },
  "e413": {
    "id": "e413",
    "label": "I want to switch to another Observable",
    "options": [
      "b988"
    ]
  },
  "1d51": {
    "id": "1d51",
    "label": "after a period of inactivity",
    "options": [
      "d2ea",
      "e413"
    ]
  },
  "257c": {
    "id": "257c",
    "label": "single"
  },
  "44a8": {
    "id": "44a8",
    "label": "I want to ensure there is only one value",
    "options": [
      "257c"
    ]
  },
  "da32": {
    "id": "da32",
    "label": "count"
  },
  "3af4": {
    "id": "3af4",
    "label": "I want to know how many values it emits",
    "options": [
      "da32"
    ]
  },
  "bf9b": {
    "id": "bf9b",
    "label": "startWith"
  },
  "0eae": {
    "id": "0eae",
    "label": "I want to prepend one value",
    "options": [
      "bf9b"
    ]
  },
  "184b": {
    "id": "184b",
    "label": "delay"
  },
  "3f6a": {
    "id": "3f6a",
    "label": "based on a given amount of time",
    "options": [
      "184b"
    ]
  },
  "2d6b": {
    "id": "2d6b",
    "label": "delayWhen"
  },
  "c3a9": {
    "id": "c3a9",
    "label": "based on the emissions of another Observable",
    "options": [
      "2d6b"
    ]
  },
  "cd9f": {
    "id": "cd9f",
    "label": "I want to delay the emissions",
    "options": [
      "3f6a",
      "c3a9"
    ]
  },
  "9d92": {
    "id": "9d92",
    "label": "toArray"
  },
  "649d": {
    "id": "649d",
    "label": "and convert to an array",
    "options": [
      "9d92"
    ]
  },
  "44d9": {
    "id": "44d9",
    "label": "Observable",
    "method": "toPromise"
  },
  "e285": {
    "id": "e285",
    "label": "and convert to a Promise",
    "options": [
      "44d9"
    ]
  },
  "194c": {
    "id": "194c",
    "label": "until the Observable completes",
    "options": [
      "649d",
      "e285"
    ]
  },
  "fb95": {
    "id": "fb95",
    "label": "pairwise"
  },
  "e46a": {
    "id": "e46a",
    "label": "consecutively in pairs, as arrays",
    "options": [
      "fb95"
    ]
  },
  "be2a": {
    "id": "be2a",
    "label": "based on a criterion, and output two Observables: those that match the criterion and those that do not",
    "options": [
      "4796"
    ]
  },
  "f2ac": {
    "id": "f2ac",
    "label": "bufferCount"
  },
  "389b": {
    "id": "389b",
    "label": "windowCount"
  },
  "fa43": {
    "id": "fa43",
    "label": "and emit the group as a nested Observable",
    "options": [
      "389b"
    ]
  },
  "f846": {
    "id": "f846",
    "label": "in batches of a particular size",
    "options": [
      "7676",
      "fa43"
    ]
  },
  "868f": {
    "id": "868f",
    "label": "bufferTime"
  },
  "512d": {
    "id": "512d",
    "label": "and emit the group as an array",
    "options": [
      "868f"
    ]
  },
  "e280": {
    "id": "e280",
    "label": "windowTime"
  },
  "f969": {
    "id": "f969",
    "label": "and emit the group as a nested Observable",
    "options": [
      "e280"
    ]
  },
  "5aa3": {
    "id": "5aa3",
    "label": "based on time",
    "options": [
      "512d",
      "f969"
    ]
  },
  "bb9f": {
    "id": "bb9f",
    "label": "buffer"
  },
  "02a1": {
    "id": "02a1",
    "label": "and emit the group as an array",
    "options": [
      "bb9f"
    ]
  },
  "2b2e": {
    "id": "2b2e",
    "label": "window"
  },
  "086e": {
    "id": "086e",
    "label": "and emit the group as a nested Observable",
    "options": [
      "2b2e"
    ]
  },
  "326a": {
    "id": "326a",
    "label": "until another Observable emits",
    "options": [
      "02a1",
      "086e"
    ]
  },
  "821d": {
    "id": "821d",
    "label": "bufferWhen"
  },
  "02bf": {
    "id": "02bf",
    "label": "and emit the group as an array",
    "options": [
      "821d"
    ]
  },
  "0cdd": {
    "id": "0cdd",
    "label": "windowWhen"
  },
  "10c7": {
    "id": "10c7",
    "label": "and emit the group as a nested Observable",
    "options": [
      "0cdd"
    ]
  },
  "7aa7": {
    "id": "7aa7",
    "label": "based on the emissions of an Observable created on-demand",
    "options": [
      "02bf",
      "10c7"
    ]
  },
  "a758": {
    "id": "a758",
    "label": "bufferToggle"
  },
  "0d6b": {
    "id": "0d6b",
    "label": "windowToggle"
  },
  "b322": {
    "id": "b322",
    "label": "and emit the group as a nested Observable",
    "options": [
      "0d6b"
    ]
  },
  "dfca": {
    "id": "dfca",
    "label": "based on another Observable for opening a group, and an Observable for closing a group",
    "options": [
      "5119",
      "b322"
    ]
  },
  "7f01": {
    "id": "7f01",
    "label": "groupBy"
  },
  "2ef5": {
    "id": "2ef5",
    "label": "based on a key calculated from the emitted values",
    "options": [
      "7f01"
    ]
  },
  "766a": {
    "id": "766a",
    "label": "I want to group the values",
    "options": [
      "194c",
      "e46a",
      "be2a",
      "f846",
      "5aa3",
      "326a",
      "7aa7",
      "dfca",
      "2ef5"
    ]
  },
  "be5b": {
    "id": "be5b",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "4998"
    ]
  },
  "bfee": {
    "id": "bfee",
    "label": "mergeMap"
  },
  "c9ca": {
    "id": "c9ca",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "bfee"
    ]
  },
  "6dd3": {
    "id": "6dd3",
    "label": "and emit the values from all nested Observables in parallel",
    "options": [
      "be5b",
      "c9ca"
    ]
  },
  "558f": {
    "id": "558f",
    "label": "concatMapTo"
  },
  "3c0c": {
    "id": "3c0c",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "558f"
    ]
  },
  "74e6": {
    "id": "74e6",
    "label": "concatMap"
  },
  "c9ac": {
    "id": "c9ac",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "74e6"
    ]
  },
  "3f2a": {
    "id": "3f2a",
    "label": "and emit the values from each nested Observable in order",
    "options": [
      "3c0c",
      "c9ac"
    ]
  },
  "0b16": {
    "id": "0b16",
    "label": "switchMapTo"
  },
  "f079": {
    "id": "f079",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "0b16"
    ]
  },
  "2dd5": {
    "id": "2dd5",
    "label": "switchMap"
  },
  "d1bb": {
    "id": "d1bb",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "2dd5"
    ]
  },
  "a772": {
    "id": "a772",
    "label": "and cancel the previous nested Observable when a new value arrives",
    "options": [
      "f079",
      "d1bb"
    ]
  },
  "7fce": {
    "id": "7fce",
    "label": "exhaustMap"
  },
  "01d1": {
    "id": "01d1",
    "label": "and ignore incoming values while the current nested Observable has not yet completed",
    "options": [
      "7fce"
    ]
  },
  "754c": {
    "id": "754c",
    "label": "and recursively start a new Observable for each new value",
    "options": [
      "9592"
    ]
  },
  "395d": {
    "id": "395d",
    "label": "I want to start a new Observable for each value",
    "options": [
      "6dd3",
      "3f2a",
      "a772",
      "01d1",
      "754c"
    ]
  },
  "5a1c": {
    "id": "5a1c",
    "label": "pipe"
  },
  "58b9": {
    "id": "58b9",
    "label": "I want to perform custom operations",
    "options": [
      "5a1c"
    ]
  },
  "0478": {
    "id": "0478",
    "label": "share"
  },
  "d9c6": {
    "id": "d9c6",
    "label": "and start it as soon as the first subscriber arrives",
    "options": [
      "0478"
    ]
  },
  "6a3c": {
    "id": "6a3c",
    "label": "publish"
  },
  "a17b": {
    "id": "a17b",
    "label": "and start it manually or imperatively",
    "options": [
      "6a3c"
    ]
  },
  "cf8f": {
    "id": "cf8f",
    "label": "using a conventional Subject",
    "options": [
      "d9c6",
      "a17b"
    ]
  },
  "d794": {
    "id": "d794",
    "label": "publishBehavior"
  },
  "789d": {
    "id": "789d",
    "label": "publishReplay"
  },
  "efab": {
    "id": "efab",
    "label": "using a ReplaySubject",
    "options": [
      "789d"
    ]
  },
  "60d4": {
    "id": "60d4",
    "label": "publishLast"
  },
  "ecf2": {
    "id": "ecf2",
    "label": "using an AsyncSubject",
    "options": [
      "60d4"
    ]
  },
  "822c": {
    "id": "822c",
    "label": "multicast"
  },
  "7cd2": {
    "id": "7cd2",
    "label": "using a specific subject implementation",
    "options": [
      "822c"
    ]
  },
  "090a": {
    "id": "090a",
    "label": "I want to share a subscription between multiple subscribers",
    "options": [
      "cf8f",
      "5197",
      "efab",
      "ecf2",
      "7cd2"
    ]
  },
  "a9cf": {
    "id": "a9cf",
    "label": "catchError"
  },
  "e3b6": {
    "id": "e3b6",
    "label": "I want to start a new Observable",
    "options": [
      "a9cf"
    ]
  },
  "95b1": {
    "id": "95b1",
    "label": "retry"
  },
  "bd12": {
    "id": "bd12",
    "label": "immediately",
    "options": [
      "95b1"
    ]
  },
  "7a36": {
    "id": "7a36",
    "label": "retryWhen"
  },
  "b7f3": {
    "id": "b7f3",
    "label": "when another Observable emits",
    "options": [
      "7a36"
    ]
  },
  "58dc": {
    "id": "58dc",
    "label": "I want to re-subscribe",
    "options": [
      "bd12",
      "b7f3"
    ]
  },
  "2e9e": {
    "id": "2e9e",
    "label": "repeat"
  },
  "a0f5": {
    "id": "a0f5",
    "label": "immediately",
    "options": [
      "2e9e"
    ]
  },
  "eb25": {
    "id": "eb25",
    "label": "repeatWhen"
  },
  "d5df": {
    "id": "d5df",
    "label": "when another Observable emits",
    "options": [
      "eb25"
    ]
  },
  "fbb2": {
    "id": "fbb2",
    "label": "I want to re-subscribe",
    "options": [
      "a0f5",
      "d5df"
    ]
  },
  "b7b7": {
    "id": "b7b7",
    "label": "concat"
  },
  "e19f": {
    "id": "e19f",
    "label": "I want to start a new Observable",
    "options": [
      "b7b7"
    ]
  },
  "df4a": {
    "id": "df4a",
    "label": "when it completes",
    "options": [
      "fbb2",
      "e19f"
    ]
  },
  "7d73": {
    "id": "7d73",
    "label": "finalize"
  },
  "25ea": {
    "id": "25ea",
    "label": "when it completes, errors or unsubscribes, I want to execute a function",
    "options": [
      "7d73"
    ]
  },
  "8f5f": {
    "id": "8f5f",
    "label": "subscribeOn"
  },
  "c735": {
    "id": "c735",
    "label": "that routes calls to subscribe",
    "options": [
      "8f5f"
    ]
  },
  "89b0": {
    "id": "89b0",
    "label": "observeOn"
  },
  "1d55": {
    "id": "1d55",
    "label": "that routes values to observers",
    "options": [
      "89b0"
    ]
  },
  "7c2c": {
    "id": "7c2c",
    "label": "I want to change the scheduler",
    "options": [
      "c735",
      "1d55"
    ]
  },
  "ca8a": {
    "id": "ca8a",
    "label": "race"
  },
  "0cd4": {
    "id": "0cd4",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "ca8a"
    ]
  },
  "15d4": {
    "id": "15d4",
    "label": "merge"
  },
  "c768": {
    "id": "c768",
    "label": "I want to output the values from either of them",
    "options": [
      "15d4"
    ]
  },
  "b3d2": {
    "id": "b3d2",
    "label": "combineLatest"
  },
  "2b9d": {
    "id": "2b9d",
    "label": "withLatestFrom"
  },
  "345d": {
    "id": "345d",
    "label": "zip"
  },
  "a0d1": {
    "id": "a0d1",
    "label": "using each source value only once",
    "options": [
      "345d"
    ]
  },
  "0370": {
    "id": "0370",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "6807",
      "8694",
      "a0d1"
    ]
  },
  "d558": {
    "id": "d558",
    "label": "I want to combine this Observable with others, and",
    "options": [
      "0cd4",
      "c768",
      "0370"
    ]
  },
  "802a": {
    "id": "802a",
    "label": "I have one existing Observable, and",
    "options": [
      "75cf",
      "b4a7",
      "c869",
      "0b10",
      "55e2",
      "21e4",
      "dc2a",
      "1d51",
      "44a8",
      "3af4",
      "0eae",
      "cd9f",
      "766a",
      "395d",
      "58b9",
      "090a",
      "8744",
      "df4a",
      "25ea",
      "7c2c",
      "d558"
    ]
  },
  "f8ef": {
    "id": "f8ef",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "4280"
    ]
  },
  "c085": {
    "id": "c085",
    "label": "forkJoin"
  },
  "340c": {
    "id": "340c",
    "label": "I want to be notified when all of them have completed",
    "options": [
      "c085"
    ]
  },
  "c9ae": {
    "id": "c9ae",
    "label": "merge"
  },
  "f103": {
    "id": "f103",
    "label": "I want to output the values from either of them",
    "options": [
      "c9ae"
    ]
  },
  "d59e": {
    "id": "d59e",
    "label": "combineLatest"
  },
  "1d8b": {
    "id": "1d8b",
    "label": "zip"
  },
  "0660": {
    "id": "0660",
    "label": "using each source value only once",
    "options": [
      "1d8b"
    ]
  },
  "41bd": {
    "id": "41bd",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "5507",
      "0660"
    ]
  },
  "e0d2": {
    "id": "e0d2",
    "label": "I have some Observables to combine together as one Observable, and",
    "options": [
      "f8ef",
      "340c",
      "f103",
      "41bd",
      "1012"
    ]
  },
  "40ff": {
    "id": "40ff",
    "label": "Observable",
    "method": "create"
  },
  "bfb4": {
    "id": "bfb4",
    "label": "using custom logic",
    "options": [
      "40ff"
    ]
  },
  "2ab2": {
    "id": "2ab2",
    "label": "generate"
  },
  "11c4": {
    "id": "11c4",
    "label": "throwError"
  },
  "586a": {
    "id": "586a",
    "label": "that throws an error",
    "options": [
      "11c4"
    ]
  },
  "ed2a": {
    "id": "ed2a",
    "label": "EMPTY"
  },
  "c58a": {
    "id": "c58a",
    "label": "that just completes, without emitting values",
    "options": [
      "ed2a"
    ]
  },
  "9e27": {
    "id": "9e27",
    "label": "that never emits anything",
    "options": [
      "5731"
    ]
  },
  "ef64": {
    "id": "ef64",
    "label": "fromEvent"
  },
  "7e71": {
    "id": "7e71",
    "label": "coming from the DOM or Node.js or similar",
    "options": [
      "ef64"
    ]
  },
  "3efc": {
    "id": "3efc",
    "label": "that uses an API to add and remove event handlers",
    "options": [
      "3902"
    ]
  },
  "a0fe": {
    "id": "a0fe",
    "label": "from an existing source of events",
    "options": [
      "7e71",
      "3efc"
    ]
  },
  "d28f": {
    "id": "d28f",
    "label": "from a Promise or an event source",
    "options": [
      "7491"
    ]
  },
  "99c3": {
    "id": "99c3",
    "label": "over the values in an array",
    "options": [
      "6150"
    ]
  },
  "985e": {
    "id": "985e",
    "label": "range"
  },
  "ff53": {
    "id": "ff53",
    "label": "over values in a numeric range",
    "options": [
      "985e"
    ]
  },
  "a384": {
    "id": "a384",
    "label": "of"
  },
  "310c": {
    "id": "310c",
    "label": "over prefined values given as arguments",
    "options": [
      "a384"
    ]
  },
  "3c7f": {
    "id": "3c7f",
    "label": "that iterates",
    "options": [
      "99c3",
      "ff53",
      "310c"
    ]
  },
  "7d72": {
    "id": "7d72",
    "label": "regularly",
    "options": [
      "6901"
    ]
  },
  "06e1": {
    "id": "06e1",
    "label": "with an optional initial delay",
    "options": [
      "7549"
    ]
  },
  "f418": {
    "id": "f418",
    "label": "defer"
  },
  "aefc": {
    "id": "aefc",
    "label": "which is built on demand when subscribed",
    "options": [
      "f418"
    ]
  },
  "a311": {
    "id": "a311",
    "label": "bindCallback"
  },
  "0ce5": {
    "id": "0ce5",
    "label": "supporting a conventional callback API",
    "options": [
      "a311"
    ]
  },
  "ed4d": {
    "id": "ed4d",
    "label": "supporting Node.js callback style API",
    "options": [
      "7475"
    ]
  },
  "6fbd": {
    "id": "6fbd",
    "label": "I want to convert a callback to an Observable",
    "options": [
      "0ce5",
      "ed4d"
    ]
  },
  "73af": {
    "id": "73af",
    "label": "I have no Observables yet, and",
    "options": [
      "4885",
      "6fbd"
    ]
  },
  "initial": {
    "id": "initial",
    "options": [
      "802a",
      "e0d2",
      "73af"
    ]
  }
}