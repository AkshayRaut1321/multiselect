{
  "1027": {
    "id": "1027",
    "label": "toArray"
  },
  "1418": {
    "id": "1418",
    "label": "publishBehavior"
  },
  "1446": {
    "id": "1446",
    "label": "publishLast"
  },
  "1934": {
    "id": "1934",
    "label": "pipe"
  },
  "2743": {
    "id": "2743",
    "label": "EMPTY"
  },
  "3076": {
    "id": "3076",
    "label": "over prefined values given as arguments",
    "options": [
      "7ca9"
    ]
  },
  "3171": {
    "id": "3171",
    "label": "windowCount"
  },
  "3498": {
    "id": "3498",
    "label": "I want to output the values from either of them",
    "options": [
      "9d28"
    ]
  },
  "3618": {
    "id": "3618",
    "label": "and emit the group as an array",
    "options": [
      "26bf"
    ]
  },
  "3827": {
    "id": "3827",
    "label": "that never emits anything",
    "options": [
      "b721"
    ]
  },
  "4130": {
    "id": "4130",
    "label": "and only output the final computed value",
    "options": [
      "d0d1"
    ]
  },
  "4255": {
    "id": "4255",
    "label": "where time windows are determined by a time duration",
    "options": [
      "86a9"
    ]
  },
  "4476": {
    "id": "4476",
    "label": "skipWhile"
  },
  "4590": {
    "id": "4590",
    "label": "mergeScan"
  },
  "5042": {
    "id": "5042",
    "label": "that throws an error",
    "options": [
      "44e8"
    ]
  },
  "5323": {
    "id": "5323",
    "label": "when it completes",
    "options": [
      "d355",
      "fd61"
    ]
  },
  "5434": {
    "id": "5434",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "d259"
    ]
  },
  "6105": {
    "id": "6105",
    "label": "to be a value calculated through a formula",
    "options": [
      "c79f"
    ]
  },
  "6225": {
    "id": "6225",
    "label": "withLatestFrom"
  },
  "6495": {
    "id": "6495",
    "label": "distinct"
  },
  "6679": {
    "id": "6679",
    "label": "I want to pick a property off each emitted value",
    "options": [
      "e890"
    ]
  },
  "6819": {
    "id": "6819",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "ad30"
    ]
  },
  "7000": {
    "id": "7000",
    "label": "based on a criterion, and output two Observables: those that match the criterion and those that do not",
    "options": [
      "ee81"
    ]
  },
  "7110": {
    "id": "7110",
    "label": "fromEvent"
  },
  "7502": {
    "id": "7502",
    "label": "from a Promise or an event source",
    "options": [
      "17c6"
    ]
  },
  "7693": {
    "id": "7693",
    "label": "bufferCount"
  },
  "7725": {
    "id": "7725",
    "label": "emitted just before the current value",
    "options": [
      "e0f5"
    ]
  },
  "7727": {
    "id": "7727",
    "label": "mergeMap"
  },
  "7810": {
    "id": "7810",
    "label": "according to a key or object property",
    "options": [
      "7725"
    ]
  },
  "8518": {
    "id": "8518",
    "label": "from the end of the Observable",
    "options": [
      "c4d0"
    ]
  },
  "8525": {
    "id": "8525",
    "label": "based on a given amount",
    "options": [
      "332a"
    ]
  },
  "9823": {
    "id": "9823",
    "label": "in batches of a particular size",
    "options": [
      "2d3d",
      "a0fd"
    ]
  },
  "9890": {
    "id": "9890",
    "label": "based on time",
    "options": [
      "3618",
      "f6df"
    ]
  },
  "9972": {
    "id": "9972",
    "label": "based on a given amount",
    "options": [
      "9c65"
    ]
  },
  "2e25": {
    "id": "2e25",
    "label": "mapTo"
  },
  "a379": {
    "id": "a379",
    "label": "to be a constant value",
    "options": [
      "2e25"
    ]
  },
  "c79f": {
    "id": "c79f",
    "label": "map"
  },
  "783e": {
    "id": "783e",
    "label": "I want to change each emitted value",
    "options": [
      "a379",
      "6105"
    ]
  },
  "e890": {
    "id": "e890",
    "label": "pluck"
  },
  "d8bf": {
    "id": "d8bf",
    "label": "tap"
  },
  "9a1e": {
    "id": "9a1e",
    "label": "I want to spy the values being emitted without affecting them",
    "options": [
      "d8bf"
    ]
  },
  "0169": {
    "id": "0169",
    "label": "filter"
  },
  "aeef": {
    "id": "aeef",
    "label": "based on custom logic",
    "options": [
      "0169"
    ]
  },
  "c3e3": {
    "id": "c3e3",
    "label": "first"
  },
  "6d43": {
    "id": "6d43",
    "label": "and only the first value",
    "options": [
      "c3e3"
    ]
  },
  "332a": {
    "id": "332a",
    "label": "take"
  },
  "a1fe": {
    "id": "a1fe",
    "label": "takeWhile"
  },
  "b90f": {
    "id": "b90f",
    "label": "based on custom logic",
    "options": [
      "a1fe"
    ]
  },
  "d64c": {
    "id": "d64c",
    "label": "if they are at the start of the Observable",
    "options": [
      "6d43",
      "8525",
      "b90f"
    ]
  },
  "7c89": {
    "id": "7c89",
    "label": "elementAt"
  },
  "b6a0": {
    "id": "b6a0",
    "label": "if they are exactly the n-th emission",
    "options": [
      "7c89"
    ]
  },
  "d315": {
    "id": "d315",
    "label": "last"
  },
  "62d3": {
    "id": "62d3",
    "label": "and only the last value",
    "options": [
      "d315"
    ]
  },
  "9c65": {
    "id": "9c65",
    "label": "takeLast"
  },
  "a5f2": {
    "id": "a5f2",
    "label": "if they are at the end of the Observable",
    "options": [
      "62d3",
      "9972"
    ]
  },
  "4d4a": {
    "id": "4d4a",
    "label": "takeUntil"
  },
  "7fd1": {
    "id": "7fd1",
    "label": "until another Observable emits a value",
    "options": [
      "4d4a"
    ]
  },
  "b0c8": {
    "id": "b0c8",
    "label": "I want to allow some values to pass",
    "options": [
      "aeef",
      "d64c",
      "b6a0",
      "a5f2",
      "7fd1"
    ]
  },
  "ce10": {
    "id": "ce10",
    "label": "ignoreElements"
  },
  "7cbe": {
    "id": "7cbe",
    "label": "altogether",
    "options": [
      "ce10"
    ]
  },
  "184b": {
    "id": "184b",
    "label": "skip"
  },
  "3a3d": {
    "id": "3a3d",
    "label": "based on a given amount",
    "options": [
      "184b"
    ]
  },
  "779f": {
    "id": "779f",
    "label": "based on custom logic",
    "options": [
      "4476"
    ]
  },
  "b706": {
    "id": "b706",
    "label": "from the start of the Observable",
    "options": [
      "3a3d",
      "779f"
    ]
  },
  "c4d0": {
    "id": "c4d0",
    "label": "skipLast"
  },
  "4d3d": {
    "id": "4d3d",
    "label": "skipUntil"
  },
  "a2ff": {
    "id": "a2ff",
    "label": "until another Observable emits a value",
    "options": [
      "4d3d"
    ]
  },
  "df35": {
    "id": "df35",
    "label": "distinctUntilChanged"
  },
  "81e7": {
    "id": "81e7",
    "label": "emitted just before the current value",
    "options": [
      "df35"
    ]
  },
  "f5fd": {
    "id": "f5fd",
    "label": "emitted some time in the past",
    "options": [
      "6495"
    ]
  },
  "ce84": {
    "id": "ce84",
    "label": "according to value equality",
    "options": [
      "81e7",
      "f5fd"
    ]
  },
  "e0f5": {
    "id": "e0f5",
    "label": "distinctUntilKeyChanged"
  },
  "ef73": {
    "id": "ef73",
    "label": "that match some previous value",
    "options": [
      "ce84",
      "7810"
    ]
  },
  "4c6b": {
    "id": "4c6b",
    "label": "throttle"
  },
  "aa90": {
    "id": "aa90",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "4c6b"
    ]
  },
  "86a9": {
    "id": "86a9",
    "label": "throttleTime"
  },
  "23e4": {
    "id": "23e4",
    "label": "by emitting the first value in each time window",
    "options": [
      "aa90",
      "4255"
    ]
  },
  "d919": {
    "id": "d919",
    "label": "audit"
  },
  "def5": {
    "id": "def5",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "d919"
    ]
  },
  "6ead": {
    "id": "6ead",
    "label": "auditTime"
  },
  "9d7c": {
    "id": "9d7c",
    "label": "where time windows are determined by a time duration",
    "options": [
      "6ead"
    ]
  },
  "5dba": {
    "id": "5dba",
    "label": "by emitting the last value in each time window",
    "options": [
      "def5",
      "9d7c"
    ]
  },
  "d7fb": {
    "id": "d7fb",
    "label": "debounce"
  },
  "f94f": {
    "id": "f94f",
    "label": "where the silence duration threshold is determined by another Observable",
    "options": [
      "d7fb"
    ]
  },
  "661d": {
    "id": "661d",
    "label": "debounceTime"
  },
  "c14f": {
    "id": "c14f",
    "label": "where the silence duration threshold is determined by a time duration",
    "options": [
      "661d"
    ]
  },
  "b63d": {
    "id": "b63d",
    "label": "by emitting the last value as soon as enough silence has occured",
    "options": [
      "f94f",
      "c14f"
    ]
  },
  "0bcb": {
    "id": "0bcb",
    "label": "that occur too frequently",
    "options": [
      "23e4",
      "5dba",
      "b63d"
    ]
  },
  "326c": {
    "id": "326c",
    "label": "I want to ignore values",
    "options": [
      "7cbe",
      "b706",
      "8518",
      "a2ff",
      "ef73",
      "0bcb"
    ]
  },
  "d0d1": {
    "id": "d0d1",
    "label": "reduce"
  },
  "b908": {
    "id": "b908",
    "label": "scan"
  },
  "c169": {
    "id": "c169",
    "label": "and output the computed values when the source emits a value",
    "options": [
      "b908"
    ]
  },
  "dc8f": {
    "id": "dc8f",
    "label": "and output the computed values as a nested Observable when the source emits a value",
    "options": [
      "4590"
    ]
  },
  "7f5d": {
    "id": "7f5d",
    "label": "I want to compute a formula using all values emitted",
    "options": [
      "4130",
      "c169",
      "dc8f"
    ]
  },
  "3e1e": {
    "id": "3e1e",
    "label": "materialize"
  },
  "b409": {
    "id": "b409",
    "label": "that describes each notification (next, error, or complete)",
    "options": [
      "3e1e"
    ]
  },
  "dd68": {
    "id": "dd68",
    "label": "timeInterval"
  },
  "0ff7": {
    "id": "0ff7",
    "label": "that includes the time past since the last emitted value",
    "options": [
      "dd68"
    ]
  },
  "0953": {
    "id": "0953",
    "label": "I want to wrap its messages with metadata",
    "options": [
      "b409",
      "0ff7"
    ]
  },
  "a4c3": {
    "id": "a4c3",
    "label": "timeout"
  },
  "b3e9": {
    "id": "b3e9",
    "label": "I want to throw an error",
    "options": [
      "a4c3"
    ]
  },
  "2ef2": {
    "id": "2ef2",
    "label": "timeoutWith"
  },
  "bbd4": {
    "id": "bbd4",
    "label": "I want to switch to another Observable",
    "options": [
      "2ef2"
    ]
  },
  "210a": {
    "id": "210a",
    "label": "after a period of inactivity",
    "options": [
      "b3e9",
      "bbd4"
    ]
  },
  "a982": {
    "id": "a982",
    "label": "single"
  },
  "f1c7": {
    "id": "f1c7",
    "label": "I want to ensure there is only one value",
    "options": [
      "a982"
    ]
  },
  "1c8f": {
    "id": "1c8f",
    "label": "count"
  },
  "84cd": {
    "id": "84cd",
    "label": "I want to know how many values it emits",
    "options": [
      "1c8f"
    ]
  },
  "4e1b": {
    "id": "4e1b",
    "label": "startWith"
  },
  "e8f1": {
    "id": "e8f1",
    "label": "I want to prepend one value",
    "options": [
      "4e1b"
    ]
  },
  "0175": {
    "id": "0175",
    "label": "delay"
  },
  "8b69": {
    "id": "8b69",
    "label": "based on a given amount of time",
    "options": [
      "0175"
    ]
  },
  "afa5": {
    "id": "afa5",
    "label": "delayWhen"
  },
  "c418": {
    "id": "c418",
    "label": "based on the emissions of another Observable",
    "options": [
      "afa5"
    ]
  },
  "6fca": {
    "id": "6fca",
    "label": "I want to delay the emissions",
    "options": [
      "8b69",
      "c418"
    ]
  },
  "9bc2": {
    "id": "9bc2",
    "label": "and convert to an array",
    "options": [
      "1027"
    ]
  },
  "8b92": {
    "id": "8b92",
    "label": "Observable",
    "method": "toPromise"
  },
  "3ab8": {
    "id": "3ab8",
    "label": "and convert to a Promise",
    "options": [
      "8b92"
    ]
  },
  "8c58": {
    "id": "8c58",
    "label": "until the Observable completes",
    "options": [
      "9bc2",
      "3ab8"
    ]
  },
  "378a": {
    "id": "378a",
    "label": "pairwise"
  },
  "0b55": {
    "id": "0b55",
    "label": "consecutively in pairs, as arrays",
    "options": [
      "378a"
    ]
  },
  "ee81": {
    "id": "ee81",
    "label": "partition"
  },
  "2d3d": {
    "id": "2d3d",
    "label": "and emit the group as an array",
    "options": [
      "7693"
    ]
  },
  "a0fd": {
    "id": "a0fd",
    "label": "and emit the group as a nested Observable",
    "options": [
      "3171"
    ]
  },
  "26bf": {
    "id": "26bf",
    "label": "bufferTime"
  },
  "2d69": {
    "id": "2d69",
    "label": "windowTime"
  },
  "f6df": {
    "id": "f6df",
    "label": "and emit the group as a nested Observable",
    "options": [
      "2d69"
    ]
  },
  "2f83": {
    "id": "2f83",
    "label": "buffer"
  },
  "fa2d": {
    "id": "fa2d",
    "label": "and emit the group as an array",
    "options": [
      "2f83"
    ]
  },
  "ac34": {
    "id": "ac34",
    "label": "window"
  },
  "62ed": {
    "id": "62ed",
    "label": "and emit the group as a nested Observable",
    "options": [
      "ac34"
    ]
  },
  "8e87": {
    "id": "8e87",
    "label": "until another Observable emits",
    "options": [
      "fa2d",
      "62ed"
    ]
  },
  "142d": {
    "id": "142d",
    "label": "bufferWhen"
  },
  "77da": {
    "id": "77da",
    "label": "and emit the group as an array",
    "options": [
      "142d"
    ]
  },
  "b8fc": {
    "id": "b8fc",
    "label": "windowWhen"
  },
  "18fb": {
    "id": "18fb",
    "label": "and emit the group as a nested Observable",
    "options": [
      "b8fc"
    ]
  },
  "eae0": {
    "id": "eae0",
    "label": "based on the emissions of an Observable created on-demand",
    "options": [
      "77da",
      "18fb"
    ]
  },
  "0045": {
    "id": "0045",
    "label": "bufferToggle"
  },
  "bfcc": {
    "id": "bfcc",
    "label": "and emit the group as an array",
    "options": [
      "0045"
    ]
  },
  "dcc9": {
    "id": "dcc9",
    "label": "windowToggle"
  },
  "f139": {
    "id": "f139",
    "label": "and emit the group as a nested Observable",
    "options": [
      "dcc9"
    ]
  },
  "7d32": {
    "id": "7d32",
    "label": "based on another Observable for opening a group, and an Observable for closing a group",
    "options": [
      "bfcc",
      "f139"
    ]
  },
  "d524": {
    "id": "d524",
    "label": "groupBy"
  },
  "d3b9": {
    "id": "d3b9",
    "label": "based on a key calculated from the emitted values",
    "options": [
      "d524"
    ]
  },
  "71cc": {
    "id": "71cc",
    "label": "I want to group the values",
    "options": [
      "8c58",
      "0b55",
      "7000",
      "9823",
      "9890",
      "8e87",
      "eae0",
      "7d32",
      "d3b9"
    ]
  },
  "c367": {
    "id": "c367",
    "label": "mergeMapTo"
  },
  "b6b9": {
    "id": "b6b9",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "c367"
    ]
  },
  "ecc3": {
    "id": "ecc3",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "7727"
    ]
  },
  "b490": {
    "id": "b490",
    "label": "and emit the values from all nested Observables in parallel",
    "options": [
      "b6b9",
      "ecc3"
    ]
  },
  "c255": {
    "id": "c255",
    "label": "concatMapTo"
  },
  "b092": {
    "id": "b092",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "c255"
    ]
  },
  "4dc2": {
    "id": "4dc2",
    "label": "concatMap"
  },
  "11de": {
    "id": "11de",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "4dc2"
    ]
  },
  "c23b": {
    "id": "c23b",
    "label": "and emit the values from each nested Observable in order",
    "options": [
      "b092",
      "11de"
    ]
  },
  "011d": {
    "id": "011d",
    "label": "switchMapTo"
  },
  "13a2": {
    "id": "13a2",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "011d"
    ]
  },
  "4c92": {
    "id": "4c92",
    "label": "switchMap"
  },
  "b658": {
    "id": "b658",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "4c92"
    ]
  },
  "84ef": {
    "id": "84ef",
    "label": "and cancel the previous nested Observable when a new value arrives",
    "options": [
      "13a2",
      "b658"
    ]
  },
  "79c3": {
    "id": "79c3",
    "label": "exhaustMap"
  },
  "31de": {
    "id": "31de",
    "label": "and ignore incoming values while the current nested Observable has not yet completed",
    "options": [
      "79c3"
    ]
  },
  "b176": {
    "id": "b176",
    "label": "expand"
  },
  "03fe": {
    "id": "03fe",
    "label": "and recursively start a new Observable for each new value",
    "options": [
      "b176"
    ]
  },
  "44c9": {
    "id": "44c9",
    "label": "I want to start a new Observable for each value",
    "options": [
      "b490",
      "c23b",
      "84ef",
      "31de",
      "03fe"
    ]
  },
  "53f3": {
    "id": "53f3",
    "label": "I want to perform custom operations",
    "options": [
      "1934"
    ]
  },
  "d2de": {
    "id": "d2de",
    "label": "share"
  },
  "a0cb": {
    "id": "a0cb",
    "label": "and start it as soon as the first subscriber arrives",
    "options": [
      "d2de"
    ]
  },
  "a010": {
    "id": "a010",
    "label": "publish"
  },
  "8de8": {
    "id": "8de8",
    "label": "and start it manually or imperatively",
    "options": [
      "a010"
    ]
  },
  "8ed9": {
    "id": "8ed9",
    "label": "using a conventional Subject",
    "options": [
      "a0cb",
      "8de8"
    ]
  },
  "b1b9": {
    "id": "b1b9",
    "label": "using a BehaviorSubject",
    "options": [
      "1418"
    ]
  },
  "c8b1": {
    "id": "c8b1",
    "label": "publishReplay"
  },
  "d763": {
    "id": "d763",
    "label": "using a ReplaySubject",
    "options": [
      "c8b1"
    ]
  },
  "3dd3": {
    "id": "3dd3",
    "label": "using an AsyncSubject",
    "options": [
      "1446"
    ]
  },
  "6abb": {
    "id": "6abb",
    "label": "multicast"
  },
  "5fde": {
    "id": "5fde",
    "label": "using a specific subject implementation",
    "options": [
      "6abb"
    ]
  },
  "2f75": {
    "id": "2f75",
    "label": "I want to share a subscription between multiple subscribers",
    "options": [
      "8ed9",
      "b1b9",
      "d763",
      "3dd3",
      "5fde"
    ]
  },
  "dae9": {
    "id": "dae9",
    "label": "catchError"
  },
  "5eda": {
    "id": "5eda",
    "label": "I want to start a new Observable",
    "options": [
      "dae9"
    ]
  },
  "9ec9": {
    "id": "9ec9",
    "label": "retry"
  },
  "fe88": {
    "id": "fe88",
    "label": "immediately",
    "options": [
      "9ec9"
    ]
  },
  "264e": {
    "id": "264e",
    "label": "retryWhen"
  },
  "e4d2": {
    "id": "e4d2",
    "label": "when another Observable emits",
    "options": [
      "264e"
    ]
  },
  "8e7b": {
    "id": "8e7b",
    "label": "I want to re-subscribe",
    "options": [
      "fe88",
      "e4d2"
    ]
  },
  "32ab": {
    "id": "32ab",
    "label": "when an error occurs",
    "options": [
      "5eda",
      "8e7b"
    ]
  },
  "557d": {
    "id": "557d",
    "label": "repeat"
  },
  "88e9": {
    "id": "88e9",
    "label": "immediately",
    "options": [
      "557d"
    ]
  },
  "9c23": {
    "id": "9c23",
    "label": "repeatWhen"
  },
  "5da6": {
    "id": "5da6",
    "label": "when another Observable emits",
    "options": [
      "9c23"
    ]
  },
  "d355": {
    "id": "d355",
    "label": "I want to re-subscribe",
    "options": [
      "88e9",
      "5da6"
    ]
  },
  "2f02": {
    "id": "2f02",
    "label": "concat"
  },
  "fd61": {
    "id": "fd61",
    "label": "I want to start a new Observable",
    "options": [
      "2f02"
    ]
  },
  "9c42": {
    "id": "9c42",
    "label": "finalize"
  },
  "9ac7": {
    "id": "9ac7",
    "label": "when it completes, errors or unsubscribes, I want to execute a function",
    "options": [
      "9c42"
    ]
  },
  "f413": {
    "id": "f413",
    "label": "subscribeOn"
  },
  "2f69": {
    "id": "2f69",
    "label": "that routes calls to subscribe",
    "options": [
      "f413"
    ]
  },
  "53a7": {
    "id": "53a7",
    "label": "observeOn"
  },
  "f564": {
    "id": "f564",
    "label": "that routes values to observers",
    "options": [
      "53a7"
    ]
  },
  "01b2": {
    "id": "01b2",
    "label": "I want to change the scheduler",
    "options": [
      "2f69",
      "f564"
    ]
  },
  "6e3a": {
    "id": "6e3a",
    "label": "race"
  },
  "a38e": {
    "id": "a38e",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "6e3a"
    ]
  },
  "8d0a": {
    "id": "8d0a",
    "label": "merge"
  },
  "400f": {
    "id": "400f",
    "label": "I want to output the values from either of them",
    "options": [
      "8d0a"
    ]
  },
  "ad30": {
    "id": "ad30",
    "label": "combineLatest"
  },
  "d619": {
    "id": "d619",
    "label": "using the latest value of each source only when the primary Observable emits",
    "options": [
      "6225"
    ]
  },
  "3ad5": {
    "id": "3ad5",
    "label": "zip"
  },
  "94a6": {
    "id": "94a6",
    "label": "using each source value only once",
    "options": [
      "3ad5"
    ]
  },
  "de37": {
    "id": "de37",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "6819",
      "d619",
      "94a6"
    ]
  },
  "ffe5": {
    "id": "ffe5",
    "label": "I want to combine this Observable with others, and",
    "options": [
      "a38e",
      "400f",
      "de37"
    ]
  },
  "1cd8": {
    "id": "1cd8",
    "label": "I have one existing Observable, and",
    "options": [
      "783e",
      "6679",
      "9a1e",
      "b0c8",
      "326c",
      "7f5d",
      "0953",
      "210a",
      "f1c7",
      "84cd",
      "e8f1",
      "6fca",
      "71cc",
      "44c9",
      "53f3",
      "2f75",
      "32ab",
      "5323",
      "9ac7",
      "01b2",
      "ffe5"
    ]
  },
  "11b5": {
    "id": "11b5",
    "label": "race"
  },
  "52a6": {
    "id": "52a6",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "11b5"
    ]
  },
  "00bc": {
    "id": "00bc",
    "label": "forkJoin"
  },
  "24c3": {
    "id": "24c3",
    "label": "I want to be notified when all of them have completed",
    "options": [
      "00bc"
    ]
  },
  "9d28": {
    "id": "9d28",
    "label": "merge"
  },
  "d259": {
    "id": "d259",
    "label": "combineLatest"
  },
  "ad9a": {
    "id": "ad9a",
    "label": "zip"
  },
  "4ae8": {
    "id": "4ae8",
    "label": "using each source value only once",
    "options": [
      "ad9a"
    ]
  },
  "b909": {
    "id": "b909",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "5434",
      "4ae8"
    ]
  },
  "dbb7": {
    "id": "dbb7",
    "label": "concat"
  },
  "d933": {
    "id": "d933",
    "label": "I want to subscribe to each in order",
    "options": [
      "dbb7"
    ]
  },
  "b81e": {
    "id": "b81e",
    "label": "I have some Observables to combine together as one Observable, and",
    "options": [
      "52a6",
      "24c3",
      "3498",
      "b909",
      "d933"
    ]
  },
  "c661": {
    "id": "c661",
    "label": "Observable",
    "method": "create"
  },
  "91da": {
    "id": "91da",
    "label": "using custom logic",
    "options": [
      "c661"
    ]
  },
  "a29e": {
    "id": "a29e",
    "label": "generate"
  },
  "8cb3": {
    "id": "8cb3",
    "label": "using a state machine similar to a for loop",
    "options": [
      "a29e"
    ]
  },
  "44e8": {
    "id": "44e8",
    "label": "throwError"
  },
  "fa5b": {
    "id": "fa5b",
    "label": "that just completes, without emitting values",
    "options": [
      "2743"
    ]
  },
  "b721": {
    "id": "b721",
    "label": "NEVER"
  },
  "769e": {
    "id": "769e",
    "label": "coming from the DOM or Node.js or similar",
    "options": [
      "7110"
    ]
  },
  "2d7d": {
    "id": "2d7d",
    "label": "fromEventPattern"
  },
  "840c": {
    "id": "840c",
    "label": "that uses an API to add and remove event handlers",
    "options": [
      "2d7d"
    ]
  },
  "c704": {
    "id": "c704",
    "label": "from an existing source of events",
    "options": [
      "769e",
      "840c"
    ]
  },
  "17c6": {
    "id": "17c6",
    "label": "from"
  },
  "6eeb": {
    "id": "6eeb",
    "label": "from"
  },
  "553d": {
    "id": "553d",
    "label": "over the values in an array",
    "options": [
      "6eeb"
    ]
  },
  "5a21": {
    "id": "5a21",
    "label": "range"
  },
  "6d73": {
    "id": "6d73",
    "label": "over values in a numeric range",
    "options": [
      "5a21"
    ]
  },
  "7ca9": {
    "id": "7ca9",
    "label": "of"
  },
  "94f9": {
    "id": "94f9",
    "label": "that iterates",
    "options": [
      "553d",
      "6d73",
      "3076"
    ]
  },
  "24b7": {
    "id": "24b7",
    "label": "interval"
  },
  "50af": {
    "id": "50af",
    "label": "regularly",
    "options": [
      "24b7"
    ]
  },
  "7ecf": {
    "id": "7ecf",
    "label": "timer"
  },
  "8bab": {
    "id": "8bab",
    "label": "with an optional initial delay",
    "options": [
      "7ecf"
    ]
  },
  "9dc5": {
    "id": "9dc5",
    "label": "that emits values on a timer",
    "options": [
      "50af",
      "8bab"
    ]
  },
  "1c10": {
    "id": "1c10",
    "label": "defer"
  },
  "cf01": {
    "id": "cf01",
    "label": "which is built on demand when subscribed",
    "options": [
      "1c10"
    ]
  },
  "c3ac": {
    "id": "c3ac",
    "label": "I want to create a new Observable",
    "options": [
      "91da",
      "8cb3",
      "5042",
      "fa5b",
      "3827",
      "c704",
      "7502",
      "94f9",
      "9dc5",
      "cf01"
    ]
  },
  "cd1c": {
    "id": "cd1c",
    "label": "bindCallback"
  },
  "4c44": {
    "id": "4c44",
    "label": "supporting a conventional callback API",
    "options": [
      "cd1c"
    ]
  },
  "0d2e": {
    "id": "0d2e",
    "label": "bindNodeCallback"
  },
  "56a9": {
    "id": "56a9",
    "label": "supporting Node.js callback style API",
    "options": [
      "0d2e"
    ]
  },
  "f7cb": {
    "id": "f7cb",
    "label": "I want to convert a callback to an Observable",
    "options": [
      "4c44",
      "56a9"
    ]
  },
  "b5c1": {
    "id": "b5c1",
    "label": "I have no Observables yet, and",
    "options": [
      "c3ac",
      "f7cb"
    ]
  },
  "initial": {
    "id": "initial",
    "options": [
      "1cd8",
      "b81e",
      "b5c1"
    ]
  }
}