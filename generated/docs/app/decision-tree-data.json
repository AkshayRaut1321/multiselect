{
  "1253": {
    "id": "1253",
    "label": "that iterates",
    "options": [
      "d231",
      "cfb7",
      "f30b"
    ]
  },
  "1346": {
    "id": "1346",
    "label": "I want to delay the emissions",
    "options": [
      "e518",
      "ccd8"
    ]
  },
  "1365": {
    "id": "1365",
    "label": "coming from the DOM or Node.js or similar",
    "options": [
      "ef5a"
    ]
  },
  "1498": {
    "id": "1498",
    "label": "take"
  },
  "1578": {
    "id": "1578",
    "label": "I want to perform custom operations",
    "options": [
      "adb2"
    ]
  },
  "1713": {
    "id": "1713",
    "label": "after a period of inactivity",
    "options": [
      "3d03",
      "e0c3"
    ]
  },
  "2044": {
    "id": "2044",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "8fa6"
    ]
  },
  "2194": {
    "id": "2194",
    "label": "of"
  },
  "2537": {
    "id": "2537",
    "label": "scan"
  },
  "2559": {
    "id": "2559",
    "label": "I want to output the values from either of them",
    "options": [
      "6774"
    ]
  },
  "3146": {
    "id": "3146",
    "label": "buffer"
  },
  "3183": {
    "id": "3183",
    "label": "windowToggle"
  },
  "3228": {
    "id": "3228",
    "label": "takeWhile"
  },
  "3294": {
    "id": "3294",
    "label": "pairwise"
  },
  "3932": {
    "id": "3932",
    "label": "from an existing source of events",
    "options": [
      "1365",
      "aa37"
    ]
  },
  "3933": {
    "id": "3933",
    "label": "bufferWhen"
  },
  "4024": {
    "id": "4024",
    "label": "distinctUntilKeyChanged"
  },
  "4971": {
    "id": "4971",
    "label": "where time windows are determined by a time duration",
    "options": [
      "27e0"
    ]
  },
  "4990": {
    "id": "4990",
    "label": "from"
  },
  "5552": {
    "id": "5552",
    "label": "based on another Observable for opening a group, and an Observable for closing a group",
    "options": [
      "f6f7",
      "b173"
    ]
  },
  "5762": {
    "id": "5762",
    "label": "based on the emissions of an Observable created on-demand",
    "options": [
      "72a7",
      "83ec"
    ]
  },
  "5956": {
    "id": "5956",
    "label": "immediately",
    "options": [
      "389b"
    ]
  },
  "5997": {
    "id": "5997",
    "label": "and output the computed values when the source emits a value",
    "options": [
      "2537"
    ]
  },
  "6224": {
    "id": "6224",
    "label": "according to value equality",
    "options": [
      "e740",
      "7403"
    ]
  },
  "6234": {
    "id": "6234",
    "label": "and emit the values from all nested Observables in parallel",
    "options": [
      "ffe8",
      "9598"
    ]
  },
  "6774": {
    "id": "6774",
    "label": "merge"
  },
  "6871": {
    "id": "6871",
    "label": "supporting a conventional callback API",
    "options": [
      "995b"
    ]
  },
  "6934": {
    "id": "6934",
    "label": "retryWhen"
  },
  "7029": {
    "id": "7029",
    "label": "and recursively start a new Observable for each new value",
    "options": [
      "231f"
    ]
  },
  "7369": {
    "id": "7369",
    "label": "based on custom logic",
    "options": [
      "1a21"
    ]
  },
  "7403": {
    "id": "7403",
    "label": "emitted some time in the past",
    "options": [
      "d86c"
    ]
  },
  "7518": {
    "id": "7518",
    "label": "debounceTime"
  },
  "8109": {
    "id": "8109",
    "label": "based on a key calculated from the emitted values",
    "options": [
      "a95d"
    ]
  },
  "8152": {
    "id": "8152",
    "label": "throttleTime"
  },
  "8257": {
    "id": "8257",
    "label": "subscribeOn"
  },
  "8282": {
    "id": "8282",
    "label": "I want to subscribe to each in order",
    "options": [
      "d2ed"
    ]
  },
  "8542": {
    "id": "8542",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "f74e"
    ]
  },
  "8557": {
    "id": "8557",
    "label": "generate"
  },
  "8864": {
    "id": "8864",
    "label": "immediately",
    "options": [
      "3acb"
    ]
  },
  "9155": {
    "id": "9155",
    "label": "emitted just before the current value",
    "options": [
      "4024"
    ]
  },
  "9225": {
    "id": "9225",
    "label": "last"
  },
  "9598": {
    "id": "9598",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "024f"
    ]
  },
  "9764": {
    "id": "9764",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "e9fe"
    ]
  },
  "9977": {
    "id": "9977",
    "label": "catchError"
  },
  "80d9": {
    "id": "80d9",
    "label": "mapTo"
  },
  "f71a": {
    "id": "f71a",
    "label": "to be a constant value",
    "options": [
      "80d9"
    ]
  },
  "0ab1": {
    "id": "0ab1",
    "label": "map"
  },
  "934b": {
    "id": "934b",
    "label": "to be a value calculated through a formula",
    "options": [
      "0ab1"
    ]
  },
  "d124": {
    "id": "d124",
    "label": "I want to change each emitted value",
    "options": [
      "f71a",
      "934b"
    ]
  },
  "0d14": {
    "id": "0d14",
    "label": "pluck"
  },
  "5b82": {
    "id": "5b82",
    "label": "I want to pick a property off each emitted value",
    "options": [
      "0d14"
    ]
  },
  "9e97": {
    "id": "9e97",
    "label": "tap"
  },
  "5feb": {
    "id": "5feb",
    "label": "I want to spy the values being emitted without affecting them",
    "options": [
      "9e97"
    ]
  },
  "a3ab": {
    "id": "a3ab",
    "label": "filter"
  },
  "7af5": {
    "id": "7af5",
    "label": "based on custom logic",
    "options": [
      "a3ab"
    ]
  },
  "68e9": {
    "id": "68e9",
    "label": "first"
  },
  "ff99": {
    "id": "ff99",
    "label": "and only the first value",
    "options": [
      "68e9"
    ]
  },
  "61d1": {
    "id": "61d1",
    "label": "based on a given amount",
    "options": [
      "1498"
    ]
  },
  "d573": {
    "id": "d573",
    "label": "based on custom logic",
    "options": [
      "3228"
    ]
  },
  "c306": {
    "id": "c306",
    "label": "if they are at the start of the Observable",
    "options": [
      "ff99",
      "61d1",
      "d573"
    ]
  },
  "9d07": {
    "id": "9d07",
    "label": "elementAt"
  },
  "7ada": {
    "id": "7ada",
    "label": "if they are exactly the n-th emission",
    "options": [
      "9d07"
    ]
  },
  "e398": {
    "id": "e398",
    "label": "and only the last value",
    "options": [
      "9225"
    ]
  },
  "4c9a": {
    "id": "4c9a",
    "label": "takeLast"
  },
  "843c": {
    "id": "843c",
    "label": "based on a given amount",
    "options": [
      "4c9a"
    ]
  },
  "bfa7": {
    "id": "bfa7",
    "label": "if they are at the end of the Observable",
    "options": [
      "e398",
      "843c"
    ]
  },
  "ed18": {
    "id": "ed18",
    "label": "takeUntil"
  },
  "4cc5": {
    "id": "4cc5",
    "label": "until another Observable emits a value",
    "options": [
      "ed18"
    ]
  },
  "7da8": {
    "id": "7da8",
    "label": "I want to allow some values to pass",
    "options": [
      "7af5",
      "c306",
      "7ada",
      "bfa7",
      "4cc5"
    ]
  },
  "adc5": {
    "id": "adc5",
    "label": "ignoreElements"
  },
  "4c90": {
    "id": "4c90",
    "label": "altogether",
    "options": [
      "adc5"
    ]
  },
  "8f92": {
    "id": "8f92",
    "label": "skip"
  },
  "2a8c": {
    "id": "2a8c",
    "label": "based on a given amount",
    "options": [
      "8f92"
    ]
  },
  "1a21": {
    "id": "1a21",
    "label": "skipWhile"
  },
  "ceb5": {
    "id": "ceb5",
    "label": "from the start of the Observable",
    "options": [
      "2a8c",
      "7369"
    ]
  },
  "688d": {
    "id": "688d",
    "label": "skipLast"
  },
  "a201": {
    "id": "a201",
    "label": "from the end of the Observable",
    "options": [
      "688d"
    ]
  },
  "0117": {
    "id": "0117",
    "label": "skipUntil"
  },
  "c030": {
    "id": "c030",
    "label": "until another Observable emits a value",
    "options": [
      "0117"
    ]
  },
  "fd69": {
    "id": "fd69",
    "label": "distinctUntilChanged"
  },
  "e740": {
    "id": "e740",
    "label": "emitted just before the current value",
    "options": [
      "fd69"
    ]
  },
  "d86c": {
    "id": "d86c",
    "label": "distinct"
  },
  "b4a9": {
    "id": "b4a9",
    "label": "according to a key or object property",
    "options": [
      "9155"
    ]
  },
  "9fb8": {
    "id": "9fb8",
    "label": "that match some previous value",
    "options": [
      "6224",
      "b4a9"
    ]
  },
  "9fd9": {
    "id": "9fd9",
    "label": "throttle"
  },
  "43aa": {
    "id": "43aa",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "9fd9"
    ]
  },
  "da70": {
    "id": "da70",
    "label": "where time windows are determined by a time duration",
    "options": [
      "8152"
    ]
  },
  "99ab": {
    "id": "99ab",
    "label": "by emitting the first value in each time window",
    "options": [
      "43aa",
      "da70"
    ]
  },
  "f66d": {
    "id": "f66d",
    "label": "audit"
  },
  "35d6": {
    "id": "35d6",
    "label": "where time windows are determined by another Observable's emissions",
    "options": [
      "f66d"
    ]
  },
  "27e0": {
    "id": "27e0",
    "label": "auditTime"
  },
  "8cfd": {
    "id": "8cfd",
    "label": "by emitting the last value in each time window",
    "options": [
      "35d6",
      "4971"
    ]
  },
  "d40b": {
    "id": "d40b",
    "label": "debounce"
  },
  "8b73": {
    "id": "8b73",
    "label": "where the silence duration threshold is determined by another Observable",
    "options": [
      "d40b"
    ]
  },
  "0b3d": {
    "id": "0b3d",
    "label": "where the silence duration threshold is determined by a time duration",
    "options": [
      "7518"
    ]
  },
  "587f": {
    "id": "587f",
    "label": "by emitting the last value as soon as enough silence has occured",
    "options": [
      "8b73",
      "0b3d"
    ]
  },
  "9c09": {
    "id": "9c09",
    "label": "that occur too frequently",
    "options": [
      "99ab",
      "8cfd",
      "587f"
    ]
  },
  "e3d6": {
    "id": "e3d6",
    "label": "I want to ignore values",
    "options": [
      "4c90",
      "ceb5",
      "a201",
      "c030",
      "9fb8",
      "9c09"
    ]
  },
  "d10e": {
    "id": "d10e",
    "label": "reduce"
  },
  "73d7": {
    "id": "73d7",
    "label": "and only output the final computed value",
    "options": [
      "d10e"
    ]
  },
  "cda1": {
    "id": "cda1",
    "label": "mergeScan"
  },
  "182e": {
    "id": "182e",
    "label": "and output the computed values as a nested Observable when the source emits a value",
    "options": [
      "cda1"
    ]
  },
  "72b1": {
    "id": "72b1",
    "label": "I want to compute a formula using all values emitted",
    "options": [
      "73d7",
      "5997",
      "182e"
    ]
  },
  "94fb": {
    "id": "94fb",
    "label": "materialize"
  },
  "81f0": {
    "id": "81f0",
    "label": "that describes each notification (next, error, or complete)",
    "options": [
      "94fb"
    ]
  },
  "019e": {
    "id": "019e",
    "label": "timeInterval"
  },
  "b6bd": {
    "id": "b6bd",
    "label": "that includes the time past since the last emitted value",
    "options": [
      "019e"
    ]
  },
  "a131": {
    "id": "a131",
    "label": "I want to wrap its messages with metadata",
    "options": [
      "81f0",
      "b6bd"
    ]
  },
  "4fee": {
    "id": "4fee",
    "label": "timeout"
  },
  "3d03": {
    "id": "3d03",
    "label": "I want to throw an error",
    "options": [
      "4fee"
    ]
  },
  "3a25": {
    "id": "3a25",
    "label": "timeoutWith"
  },
  "e0c3": {
    "id": "e0c3",
    "label": "I want to switch to another Observable",
    "options": [
      "3a25"
    ]
  },
  "560f": {
    "id": "560f",
    "label": "single"
  },
  "dad2": {
    "id": "dad2",
    "label": "I want to ensure there is only one value",
    "options": [
      "560f"
    ]
  },
  "adaa": {
    "id": "adaa",
    "label": "count"
  },
  "e005": {
    "id": "e005",
    "label": "I want to know how many values it emits",
    "options": [
      "adaa"
    ]
  },
  "b277": {
    "id": "b277",
    "label": "startWith"
  },
  "fb6a": {
    "id": "fb6a",
    "label": "I want to prepend one value",
    "options": [
      "b277"
    ]
  },
  "eaa1": {
    "id": "eaa1",
    "label": "delay"
  },
  "e518": {
    "id": "e518",
    "label": "based on a given amount of time",
    "options": [
      "eaa1"
    ]
  },
  "d82f": {
    "id": "d82f",
    "label": "delayWhen"
  },
  "ccd8": {
    "id": "ccd8",
    "label": "based on the emissions of another Observable",
    "options": [
      "d82f"
    ]
  },
  "d250": {
    "id": "d250",
    "label": "toArray"
  },
  "ca6c": {
    "id": "ca6c",
    "label": "and convert to an array",
    "options": [
      "d250"
    ]
  },
  "266a": {
    "id": "266a",
    "label": "Observable",
    "method": "toPromise"
  },
  "450f": {
    "id": "450f",
    "label": "and convert to a Promise",
    "options": [
      "266a"
    ]
  },
  "6f62": {
    "id": "6f62",
    "label": "until the Observable completes",
    "options": [
      "ca6c",
      "450f"
    ]
  },
  "3ea8": {
    "id": "3ea8",
    "label": "consecutively in pairs, as arrays",
    "options": [
      "3294"
    ]
  },
  "b9e5": {
    "id": "b9e5",
    "label": "partition"
  },
  "367e": {
    "id": "367e",
    "label": "based on a criterion, and output two Observables: those that match the criterion and those that do not",
    "options": [
      "b9e5"
    ]
  },
  "a936": {
    "id": "a936",
    "label": "bufferCount"
  },
  "dad1": {
    "id": "dad1",
    "label": "and emit the group as an array",
    "options": [
      "a936"
    ]
  },
  "b114": {
    "id": "b114",
    "label": "windowCount"
  },
  "d9e4": {
    "id": "d9e4",
    "label": "and emit the group as a nested Observable",
    "options": [
      "b114"
    ]
  },
  "897f": {
    "id": "897f",
    "label": "in batches of a particular size",
    "options": [
      "dad1",
      "d9e4"
    ]
  },
  "91a1": {
    "id": "91a1",
    "label": "bufferTime"
  },
  "69b4": {
    "id": "69b4",
    "label": "and emit the group as an array",
    "options": [
      "91a1"
    ]
  },
  "820a": {
    "id": "820a",
    "label": "windowTime"
  },
  "86ad": {
    "id": "86ad",
    "label": "and emit the group as a nested Observable",
    "options": [
      "820a"
    ]
  },
  "d7e2": {
    "id": "d7e2",
    "label": "based on time",
    "options": [
      "69b4",
      "86ad"
    ]
  },
  "ca4b": {
    "id": "ca4b",
    "label": "and emit the group as an array",
    "options": [
      "3146"
    ]
  },
  "1e1f": {
    "id": "1e1f",
    "label": "window"
  },
  "e093": {
    "id": "e093",
    "label": "and emit the group as a nested Observable",
    "options": [
      "1e1f"
    ]
  },
  "42ed": {
    "id": "42ed",
    "label": "until another Observable emits",
    "options": [
      "ca4b",
      "e093"
    ]
  },
  "72a7": {
    "id": "72a7",
    "label": "and emit the group as an array",
    "options": [
      "3933"
    ]
  },
  "4c6a": {
    "id": "4c6a",
    "label": "windowWhen"
  },
  "83ec": {
    "id": "83ec",
    "label": "and emit the group as a nested Observable",
    "options": [
      "4c6a"
    ]
  },
  "29e0": {
    "id": "29e0",
    "label": "bufferToggle"
  },
  "f6f7": {
    "id": "f6f7",
    "label": "and emit the group as an array",
    "options": [
      "29e0"
    ]
  },
  "b173": {
    "id": "b173",
    "label": "and emit the group as a nested Observable",
    "options": [
      "3183"
    ]
  },
  "a95d": {
    "id": "a95d",
    "label": "groupBy"
  },
  "4c25": {
    "id": "4c25",
    "label": "I want to group the values",
    "options": [
      "6f62",
      "3ea8",
      "367e",
      "897f",
      "d7e2",
      "42ed",
      "5762",
      "5552",
      "8109"
    ]
  },
  "6e22": {
    "id": "6e22",
    "label": "mergeMapTo"
  },
  "ffe8": {
    "id": "ffe8",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "6e22"
    ]
  },
  "024f": {
    "id": "024f",
    "label": "mergeMap"
  },
  "f74e": {
    "id": "f74e",
    "label": "concatMapTo"
  },
  "48f4": {
    "id": "48f4",
    "label": "concatMap"
  },
  "e186": {
    "id": "e186",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "48f4"
    ]
  },
  "98ca": {
    "id": "98ca",
    "label": "and emit the values from each nested Observable in order",
    "options": [
      "8542",
      "e186"
    ]
  },
  "42c6": {
    "id": "42c6",
    "label": "switchMapTo"
  },
  "f6ab": {
    "id": "f6ab",
    "label": "where the nested Observable is the same for every value",
    "options": [
      "42c6"
    ]
  },
  "6ead": {
    "id": "6ead",
    "label": "switchMap"
  },
  "b46b": {
    "id": "b46b",
    "label": "where the nested Observable is calculated for each value",
    "options": [
      "6ead"
    ]
  },
  "e4db": {
    "id": "e4db",
    "label": "and cancel the previous nested Observable when a new value arrives",
    "options": [
      "f6ab",
      "b46b"
    ]
  },
  "a932": {
    "id": "a932",
    "label": "exhaustMap"
  },
  "9ca8": {
    "id": "9ca8",
    "label": "and ignore incoming values while the current nested Observable has not yet completed",
    "options": [
      "a932"
    ]
  },
  "231f": {
    "id": "231f",
    "label": "expand"
  },
  "aca9": {
    "id": "aca9",
    "label": "I want to start a new Observable for each value",
    "options": [
      "6234",
      "98ca",
      "e4db",
      "9ca8",
      "7029"
    ]
  },
  "adb2": {
    "id": "adb2",
    "label": "pipe"
  },
  "cb05": {
    "id": "cb05",
    "label": "share"
  },
  "ccab": {
    "id": "ccab",
    "label": "and start it as soon as the first subscriber arrives",
    "options": [
      "cb05"
    ]
  },
  "d5ae": {
    "id": "d5ae",
    "label": "publish"
  },
  "166e": {
    "id": "166e",
    "label": "and start it manually or imperatively",
    "options": [
      "d5ae"
    ]
  },
  "4f71": {
    "id": "4f71",
    "label": "using a conventional Subject",
    "options": [
      "ccab",
      "166e"
    ]
  },
  "c86f": {
    "id": "c86f",
    "label": "publishBehavior"
  },
  "1aa1": {
    "id": "1aa1",
    "label": "using a BehaviorSubject",
    "options": [
      "c86f"
    ]
  },
  "4bbf": {
    "id": "4bbf",
    "label": "publishReplay"
  },
  "502b": {
    "id": "502b",
    "label": "using a ReplaySubject",
    "options": [
      "4bbf"
    ]
  },
  "ba3f": {
    "id": "ba3f",
    "label": "publishLast"
  },
  "ca23": {
    "id": "ca23",
    "label": "using an AsyncSubject",
    "options": [
      "ba3f"
    ]
  },
  "a41e": {
    "id": "a41e",
    "label": "multicast"
  },
  "69c4": {
    "id": "69c4",
    "label": "using a specific subject implementation",
    "options": [
      "a41e"
    ]
  },
  "ba95": {
    "id": "ba95",
    "label": "I want to share a subscription between multiple subscribers",
    "options": [
      "4f71",
      "1aa1",
      "502b",
      "ca23",
      "69c4"
    ]
  },
  "51fd": {
    "id": "51fd",
    "label": "I want to start a new Observable",
    "options": [
      "9977"
    ]
  },
  "3acb": {
    "id": "3acb",
    "label": "retry"
  },
  "7d7e": {
    "id": "7d7e",
    "label": "when another Observable emits",
    "options": [
      "6934"
    ]
  },
  "29f5": {
    "id": "29f5",
    "label": "I want to re-subscribe",
    "options": [
      "8864",
      "7d7e"
    ]
  },
  "f05c": {
    "id": "f05c",
    "label": "when an error occurs",
    "options": [
      "51fd",
      "29f5"
    ]
  },
  "389b": {
    "id": "389b",
    "label": "repeat"
  },
  "a4ae": {
    "id": "a4ae",
    "label": "repeatWhen"
  },
  "8f1c": {
    "id": "8f1c",
    "label": "when another Observable emits",
    "options": [
      "a4ae"
    ]
  },
  "1d25": {
    "id": "1d25",
    "label": "I want to re-subscribe",
    "options": [
      "5956",
      "8f1c"
    ]
  },
  "ca9c": {
    "id": "ca9c",
    "label": "concat"
  },
  "1dd0": {
    "id": "1dd0",
    "label": "I want to start a new Observable",
    "options": [
      "ca9c"
    ]
  },
  "1d73": {
    "id": "1d73",
    "label": "when it completes",
    "options": [
      "1d25",
      "1dd0"
    ]
  },
  "dbe0": {
    "id": "dbe0",
    "label": "finalize"
  },
  "a6ce": {
    "id": "a6ce",
    "label": "when it completes, errors or unsubscribes, I want to execute a function",
    "options": [
      "dbe0"
    ]
  },
  "6cf3": {
    "id": "6cf3",
    "label": "that routes calls to subscribe",
    "options": [
      "8257"
    ]
  },
  "cb3f": {
    "id": "cb3f",
    "label": "observeOn"
  },
  "9d06": {
    "id": "9d06",
    "label": "that routes values to observers",
    "options": [
      "cb3f"
    ]
  },
  "973c": {
    "id": "973c",
    "label": "I want to change the scheduler",
    "options": [
      "6cf3",
      "9d06"
    ]
  },
  "7c31": {
    "id": "7c31",
    "label": "race"
  },
  "1b6f": {
    "id": "1b6f",
    "label": "I want to receive values only from the Observable that emits a value first",
    "options": [
      "7c31"
    ]
  },
  "1c5c": {
    "id": "1c5c",
    "label": "merge"
  },
  "13ee": {
    "id": "13ee",
    "label": "I want to output the values from either of them",
    "options": [
      "1c5c"
    ]
  },
  "591e": {
    "id": "591e",
    "label": "combineLatest"
  },
  "c187": {
    "id": "c187",
    "label": "using the latest value of each source whenever any source emits",
    "options": [
      "591e"
    ]
  },
  "4e2e": {
    "id": "4e2e",
    "label": "withLatestFrom"
  },
  "e3ae": {
    "id": "e3ae",
    "label": "using the latest value of each source only when the primary Observable emits",
    "options": [
      "4e2e"
    ]
  },
  "2f8f": {
    "id": "2f8f",
    "label": "zip"
  },
  "24c6": {
    "id": "24c6",
    "label": "using each source value only once",
    "options": [
      "2f8f"
    ]
  },
  "a2d2": {
    "id": "a2d2",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "c187",
      "e3ae",
      "24c6"
    ]
  },
  "d082": {
    "id": "d082",
    "label": "I want to combine this Observable with others, and",
    "options": [
      "1b6f",
      "13ee",
      "a2d2"
    ]
  },
  "a62b": {
    "id": "a62b",
    "label": "I have one existing Observable, and",
    "options": [
      "d124",
      "5b82",
      "5feb",
      "7da8",
      "e3d6",
      "72b1",
      "a131",
      "1713",
      "dad2",
      "e005",
      "fb6a",
      "1346",
      "4c25",
      "aca9",
      "1578",
      "ba95",
      "f05c",
      "1d73",
      "a6ce",
      "973c",
      "d082"
    ]
  },
  "8fa6": {
    "id": "8fa6",
    "label": "race"
  },
  "fa5c": {
    "id": "fa5c",
    "label": "forkJoin"
  },
  "2abe": {
    "id": "2abe",
    "label": "I want to be notified when all of them have completed",
    "options": [
      "fa5c"
    ]
  },
  "e9fe": {
    "id": "e9fe",
    "label": "combineLatest"
  },
  "ef5d": {
    "id": "ef5d",
    "label": "zip"
  },
  "fce9": {
    "id": "fce9",
    "label": "using each source value only once",
    "options": [
      "ef5d"
    ]
  },
  "504c": {
    "id": "504c",
    "label": "I want to output a value computed from values of the source Observables",
    "options": [
      "9764",
      "fce9"
    ]
  },
  "d2ed": {
    "id": "d2ed",
    "label": "concat"
  },
  "9fc4": {
    "id": "9fc4",
    "label": "I have some Observables to combine together as one Observable, and",
    "options": [
      "2044",
      "2abe",
      "2559",
      "504c",
      "8282"
    ]
  },
  "770b": {
    "id": "770b",
    "label": "Observable",
    "method": "create"
  },
  "0c27": {
    "id": "0c27",
    "label": "using custom logic",
    "options": [
      "770b"
    ]
  },
  "51e2": {
    "id": "51e2",
    "label": "using a state machine similar to a for loop",
    "options": [
      "8557"
    ]
  },
  "e9a2": {
    "id": "e9a2",
    "label": "throwError"
  },
  "6d7f": {
    "id": "6d7f",
    "label": "that throws an error",
    "options": [
      "e9a2"
    ]
  },
  "67df": {
    "id": "67df",
    "label": "EMPTY"
  },
  "6bac": {
    "id": "6bac",
    "label": "that just completes, without emitting values",
    "options": [
      "67df"
    ]
  },
  "9b98": {
    "id": "9b98",
    "label": "NEVER"
  },
  "4fda": {
    "id": "4fda",
    "label": "that never emits anything",
    "options": [
      "9b98"
    ]
  },
  "ef5a": {
    "id": "ef5a",
    "label": "fromEvent"
  },
  "42ec": {
    "id": "42ec",
    "label": "fromEventPattern"
  },
  "aa37": {
    "id": "aa37",
    "label": "that uses an API to add and remove event handlers",
    "options": [
      "42ec"
    ]
  },
  "9f06": {
    "id": "9f06",
    "label": "from"
  },
  "ab93": {
    "id": "ab93",
    "label": "from a Promise or an event source",
    "options": [
      "9f06"
    ]
  },
  "d231": {
    "id": "d231",
    "label": "over the values in an array",
    "options": [
      "4990"
    ]
  },
  "c79b": {
    "id": "c79b",
    "label": "range"
  },
  "cfb7": {
    "id": "cfb7",
    "label": "over values in a numeric range",
    "options": [
      "c79b"
    ]
  },
  "f30b": {
    "id": "f30b",
    "label": "over prefined values given as arguments",
    "options": [
      "2194"
    ]
  },
  "0dda": {
    "id": "0dda",
    "label": "interval"
  },
  "b87a": {
    "id": "b87a",
    "label": "regularly",
    "options": [
      "0dda"
    ]
  },
  "4a22": {
    "id": "4a22",
    "label": "timer"
  },
  "f096": {
    "id": "f096",
    "label": "with an optional initial delay",
    "options": [
      "4a22"
    ]
  },
  "907f": {
    "id": "907f",
    "label": "that emits values on a timer",
    "options": [
      "b87a",
      "f096"
    ]
  },
  "8c61": {
    "id": "8c61",
    "label": "defer"
  },
  "3a4b": {
    "id": "3a4b",
    "label": "which is built on demand when subscribed",
    "options": [
      "8c61"
    ]
  },
  "9dee": {
    "id": "9dee",
    "label": "I want to create a new Observable",
    "options": [
      "0c27",
      "51e2",
      "6d7f",
      "6bac",
      "4fda",
      "3932",
      "ab93",
      "1253",
      "907f",
      "3a4b"
    ]
  },
  "995b": {
    "id": "995b",
    "label": "bindCallback"
  },
  "048c": {
    "id": "048c",
    "label": "bindNodeCallback"
  },
  "63c8": {
    "id": "63c8",
    "label": "supporting Node.js callback style API",
    "options": [
      "048c"
    ]
  },
  "69d7": {
    "id": "69d7",
    "label": "I want to convert a callback to an Observable",
    "options": [
      "6871",
      "63c8"
    ]
  },
  "46af": {
    "id": "46af",
    "label": "I have no Observables yet, and",
    "options": [
      "9dee",
      "69d7"
    ]
  },
  "initial": {
    "id": "initial",
    "options": [
      "a62b",
      "9fc4",
      "46af"
    ]
  }
}